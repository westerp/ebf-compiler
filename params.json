{"name":"Ebf-compiler","tagline":"Extended BrainFuck to pure BrainFuck compiler - now also with a brainfuck jit compiler/interpreter","body":"<wiki:gadget url=\"http://hosting.gmodules.com/ig/gadgets/file/101298749992945970251/facebook-like-button.xml\" up\\_url\\_to\\_like=\"http://facebook.com/#!/pages/EBF-Compiler-suit/187363671326729\" synd=\"open\" w=\"480\" h=\"80\" output=\"js\" width=\"480\" height=\"80\" border=\"0\"  />\r\n\r\n# A self hosting Extended brainfuck to pure brainfuck compiler #\r\nEFB Compiler extends brainfuck by using extra symbols. The output will be valid brainfuck code that can run on any interpreter/compiler. If you are interested in the process of making this compiler, please go to the [Introduction](Introduction.md). To find out more about the the syntax have a look at [EBF language introduction](EBFLang.md)\r\n\r\n## Serious use: Zozotez - a LISP interpreter implemented in EBF ##\r\nThe high level goal was to be able to implement a LISP interpreter which runs on brainfuck and bootstrapped with EBF.  I have spawned a new project called **[Zozotez for creating LISP with EBF](http://code.google.com/p/zozotez/)**.\r\n\r\n\r\n## Current features ##\r\n  * Variables with variable length names\r\n  * Alternative bracket () for automatic bracket aligning\r\n  * A macro replace mechanism that is nestable with parameter passing\r\n  * multiplication of bf commands by using number in front of them. eg. 256>\r\n  * print string and store string for easy string manipulation\r\n  * All the power of `BrainFuck`. All BF programs are EBF programs :)\r\n  * Compatible with most cross compilers/interpreters. Supports all EOF convensions\r\n\r\n![http://sylwester.no/gcodeimg/lamp_50.png](http://sylwester.no/gcodeimg/lamp_50.png)\r\n\r\n\r\n## Current Commands in addition to BFs `<>+-[],.` ##\r\n\r\n_var in these examples can be any string of alphanumeric characters and underscore `[\\w_]+`._\r\n\r\n<table cellpadding='2' border='1'>\r\n<tr><th>group</th><th>function</th><th>description</th></tr>\r\n<tr><td>variable</td><td><b>:var</b></td><td>Defines a variable. It allocates variable in the order of appearance, eg. :a:b will give a position and b position 1. If you try to redefine a variable it will report ERROR. For byte-oriented interpreters/cross compilers the maximum number of variable allocated at the same time is 253.</td></tr>\r\n<tr><td><b>$var</b></td><td>Applies <'s or >'s in order to move from current position to the position allocated to variable named x. It assumes it is at position 0 at the start of the application and it will follow < and > given that you don't create an asymmetric loop.</td></tr>\r\n<tr><td><b>@var</b></td><td>To give the compiler the position after a asymmetric loop. Take for instance: <code>:a:b:c:d [&gt;-]&gt;[-&gt;] @c&lt; </code> It is impossible for the code to actually go into both loops so in reality you will always be in c and not d as the compiler thinks. </td></tr>\r\n<tr><td><b>!var</b></td><td>Deallocates variable x. It is assumed that x was the last variable allocated and will halt with an ERROR if not.</td></tr>\r\n<tr><td>structure</td><td><b>(</b>...<b>)</b></td><td>Auto-aligning brackets. <code> $a($b+++) =&gt; $a[$b+++$a] </code>. This might be used in rotating data structures like array seeking as well. consider we have an array left of <code> :c:a:z </code> which is open.. <code> $c(@z) </code> will seek until bread crumb is zero. It supports up to 251 nested loops. awib 0.2 has 18 and as of writing ebf has 12 as it's highest nesting level.</td></tr>\r\n<tr><td>macro</td><td><b>{name</b>...<b>}</b></td><td>Create macro named x. Contents will not be echoed since it might contain brainfuck code that will affect execution. A macro cannot create other macroes. When macroes are expanded ebf will treat the expanded text as ebf code, not just pure brainfuck. This enables a macro expansion to trigge runderlying macro expansins and the posibility to create complex code in layers of abstraction.</td></tr>\r\n<tr><td><b>&name</b></td><td>Insert macro x.</td></tr>\r\n<tr><td><b><code>^&lt;index&gt;</code></b></td><td>\r\n<code>^0</code> works like $var. <code>^0</code> is the cell from which the macro was called and ^1 is the first cell after making this a kind if parameter passing possible eg we have<br>\r\n:a:b:c and we are at a when invoking &a. In there <code>^ and ^0 is $a, ^1 is $b and ^2 is $c</code>.<br>\r\nIf we afterwards are at $b and call the macro, then ^0 would be $b.</td></tr>\r\n<tr><td><b><code>*&lt;+-&gt;&lt;offset&gt;</code></b></td><td>Another way to indicate offset. Like @a, but you tell the relative offset fix. Eg. <code>*-3</code> will reduce the compilers assumed position with 3. Used in combination with <code>^&lt;number&gt;</code> where macro does not know of it's real position (eg. it could be called from any position and hench reused)</td></tr>\r\n<tr><td>Syntax sugar</td><td><b><code>&lt;number&gt;&lt;+-&lt;&gt;&gt;</code></b></td><td>\r\nEg. 10+ reads like \"times 10 plus\". It replicates any of the commands <code>&lt;&gt;+-</code> the number of times indicated by the digits before the operation (+ in example). It does not have cell boundry limits. <code>512&gt;</code> is OK for 8 bit interpreter/compilers.<br>\r\n</td></tr>\r\n<tr><td><b><code>~</code>\"text\"</b></td><td>Stores the string denoted by text from the current cell. Position end up one cell to the right from the last character in the string. Example uses double quotes, but in reality any character will do, eg. <code>~*\"'^*</code> uses asterix as quote character</td></tr>\r\n<tr><td><b>|\"text\"</b></td><td>Prints the string denoted by test using the current and the next cell, which needs to be empty. Current cell contains last character after operation.Like store string you might use any quote char.<br>\r\n</td></tr>\r\n</table>\r\n\r\n## Examples,. The advantage of EBF comes apparent when dealing with larger projects than these examples ##\r\n<table border='1'>\r\n<tr><td><b>desc</b></td><td><b>EBFsource</b></td><td><b>BFobject</b></td></tr>\r\n<tr><td><code>HelloWorld</code></td><td>\r\n<pre><code>|\"Hello World\r\n<br>\r\n\"\r\n<br>\r\n</code></pre>\r\n</td><td>\r\n<pre><code>&gt;++++++++[-&lt;+++++++++&gt;]&lt;.\r\n<br>\r\n&gt;+++++[-&lt;++++++&gt;]&lt;-.+++++\r\n<br>\r\n++..+++.&gt;+++++++++[-&lt;----\r\n<br>\r\n-----&gt;]&lt;++.&gt;+++++++[-&lt;+++\r\n<br>\r\n+++++&gt;]&lt;-.&gt;+++++[-&lt;+++++&gt;\r\n<br>\r\n]&lt;-.+++.------.--------.&gt;\r\n<br>\r\n++++++++[-&lt;--------&gt;]&lt;---\r\n<br>\r\n.&gt;++++[-&lt;-----&gt;]&lt;---.\r\n<br>\r\n</code></pre>\r\n</td></tr>\r\n<tr><td>echo</td>\r\n<blockquote><td>\r\n<pre><code>;;macro definitions\r\n<br>\r\n{read $eof_flag+$input(-),[+[-&gt;-]]&gt;[@eof_flag-&gt;]}\r\n<br>\r\n{print .}\r\n<br>\r\nvar :input\r\n<br>\r\nvar :eof_flag\r\n<br>\r\n;;main program\r\n<br>\r\n&amp;read\r\n<br>\r\n$input(\r\n<br>\r\n  &amp;print\r\n<br>\r\n  &amp;read\r\n<br>\r\n)\r\n<br>\r\n</code></pre>\r\n</td>\r\n<td>\r\n<pre><code>&gt;+&lt;[-],[+[-&gt;-]]&gt;[-&gt;]&lt;&lt;[.\r\n<br>\r\n&gt;+&lt;[-],[+[-&gt;-]]&gt;[-&gt;]&lt;&lt;]\r\n<br>\r\n</code></pre>\r\n</td></tr>\r\n<tr><td>simple<br>\r\nadd</td>\r\n<td>\r\n<pre><code>{read ^1eof_flag+^0input(-),[+[-&gt;-]]&gt;[-&gt;] *-1}\r\n<br>\r\n:num1\r\n<br>\r\n:num2\r\n<br>\r\n$num1 &amp;read\r\n<br>\r\n$num2 &amp;read\r\n<br>\r\n$num1 48-\r\n<br>\r\n$num1(-$num2+)\r\n<br>\r\n$num2 .\r\n<br>\r\n</code></pre>\r\n</td><td>\r\n<pre><code>&gt;+&lt;[-],[+[-&gt;-]]&gt;[-&gt;]&lt;&gt;\r\n<br>\r\n+&lt;[-],[+[-&gt;-]]&gt;[-&gt;]&lt;&lt;&lt;\r\n<br>\r\n----------------------\r\n<br>\r\n----------------------\r\n<br>\r\n----[-&gt;+&lt;]&gt;. \r\n<br>\r\n</code></pre>\r\n</td></tr>\r\n<tr><td>reverse<br>\r\necho</td><td>\r\n<pre><code>:input\r\n<br>\r\n:end_flag\r\n<br>\r\n\r\n<br>\r\n{read\r\n<br>\r\n  $end_flag+ \r\n<br>\r\n  $input,\r\n<br>\r\n  +[11-[$end_flag-]]&gt;[@end_flag-&gt;]\r\n<br>\r\n}\r\n<br>\r\n\r\n<br>\r\n; read until linefeed/eof\r\n<br>\r\n+(-&gt;@input &amp;read ) \r\n<br>\r\n; print in reverse order\r\n<br>\r\n&lt;@input[11+.(-)&lt;] \r\n<br>\r\n; print newline\r\n<br>\r\n10+.\r\n<br>\r\n</code></pre>\r\n</td><td>\r\n<pre><code>+[-&gt;&gt;+&lt;,+[-----------[\r\n<br>\r\n&gt;-]]&gt;[-&gt;]&lt;&lt;]&lt;[++++++++\r\n<br>\r\n+++.[-]&lt;]++++++++++.\r\n<br>\r\n</code></pre>\r\n</td>\r\n</tr>\r\n</table></blockquote>\r\n\r\n[See more examples in source repository](http://code.google.com/p/ebf-compiler/source/browse/#svn%2Ftrunk%2Fexamples)\r\n\r\n\r\n# This site is a member of a `Web Ring`. #\r\nTo browse visit [The Esoteric Programming Languages Ring](http://ss.webring.com/navbar?f=l;y=webringcom44;u=defurl)\r\n<br /><br />\r\n","google":"UA-24492615-3","note":"Don't delete this file! It's used internally to help with page regeneration."}