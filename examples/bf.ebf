brainfuck interpreter
written in ebf
; char differences
;! (-23) 33
;+ (-10) 43
;, (-1) 44
;- (-1) 45
;. (-1) 46
;< (-14) 60
;> (-2) 62
;[ (-29) 91
;] (-2) 93
; optimizations
; [-] / [+] => Zero instruction
; ++ +++ ++++ +++++
; -- --- ---- -----
; << <<< <<<< <<<<
; >> >>> >>>> >>>>
; [>], [>>], [>>>]
; [<], [<<], [<<<]
; [->+], [-->++]
; [-<+], [--<++]

;[5 ... ] ... ] ... ] ...] ...]

;running the ebf compiling of utf.ebf through cgbfi2.bf
;592.01user 0.72system 9:55.76elapsed 99%CPU (0avgtext+0avgdata 15728maxresident)k
;0inputs+0outputs (0major+1054minor)pagefaults 0swaps

;running compiling of utf.ebf directly
;0.09user 0.00system 0:00.14elapsed 66%CPU (0avgtext+0avgdata 15920maxresident)k
;8inputs+0outputs (0major+1059minor)pagefaults 0swaps
0


Initially we read in all the brainfuck code and
encode it according to following
cmd
0 eoc
1 open/close bracket
2 dec
3 pinc
4 pdec
5 zero
6 seek jmp inc
7 seek jmp dec
8 seek val inc
9 seek val dec


S10*0xx1xx1xx1xx1xx1xx1xx1xx1xx1xx1xx1xx1xx1xx1xx1xx1xx1xx1xx1xx1xx1xx1xx1xx1xx1xx1xx1

weh have established it is open brackets S is positive if pointer value is not zero
S001
; $s[
;
;
; ]>>>[
; <<<+>+>+>->
; -[+>>>-]+
;
;
;
;
; ]




find matching bracket


the format is
cmd arg

except for brackets the counts are multipliers
for brackets its



>>>[ not open -[ not close >-<
:c command
:a argument
:i input
:t tmp
:w work
:e eoc

@i $e+
(
-@i $e+
  $t+$w,+[-$t-]$i[@t-$i] if 0 or 255 set to 0
  $t+ set a
  $w
  zero eof
    (----------------------- 23 eoc
     (---------- 43 plus
      (- 44 comma
       (- 45 minux
        (- 46 dot
         (-------------- 60 lt
          (-- 62 gt
           (----------------------------- 91 open
            (-- 93 close
             ( (-) $t- its a comment we delete )
          $t(-
		close
		$c+ $a
            ))
         $t(-
		open
		$
           ))
        $t(-
          ))
       $t(-
         ))
      $t(-
        ))
     $t(-
       ))
    $t(-
      ))
   $t(-
     ))
  $t(-$e-))
 $t(-$e-)
)