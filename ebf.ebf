;[
;
;ebf.ebf a bf compiler v1. In addition to existing BF (<>+-,.[])
;we have current extra commands:
;
; ;  == comment rest of line (no change)
; !a == deallocate variable a. It is assumed that is is cleared and last variable allocated
; :a == allocate variable a. It will take any available place
; $a == move to a
; @a == indicate that we are at a (usefull for asymetric loops
; like :a:b:c $b+ $a[ $b- ] either in a or b compiler thinks b $c[ @b - $c ])
;
; By Pål Wester
; ]

ML|crumble|variable|macro|zero|global|input|tmp|working|adding|position|error
PTR=765:3


:c array crumble
:v variable value
:m macro
:z zero
:g global variable index
:i input
:t temporary
:w working
:a adding aide
:p position
:e error number
++++++++++[->++++++++++<]>-----                     ; 95
[->>>>>>>[>>>>>>>>]+[<<<<<<<<]>]                    ; 8*95 = 760
>>>>>>>[->>>>>>>>]                                  ; goto 768
@z ; indicates that we are on m

$i ,[                                               ; outer loop. EOF=0

; copy $i to $w
[- $t+ $w+ $i ]                                     ; pour $i to $w and $t
$t [- $i+ $t  ]                                     ; pour $t to $i
+                                                   ; i=I|t=1|w=I|p=x
; switch
$a +++[- $w ----------- $a]                         ; reduce $w with 3*11=33(!)
 $w [---                                            ; no, reduce $w with 3($)
  [ $a++[- $w----------- $a ] $w                        ; no, reduce $w with 22(:)
   [ -                                              ; no, reduce by 1 (;)
    [ -                                             ; no, reuce by 1 (<)
     [ --                                           ; no, reuce by 2 (>)
      [ --                                          ; no, reduce by 2 (@)
       [ $i . $t- $w [-] ]                          ; reset $t and $w
       $t [-                                        ; in @
            $e++++$p[-]-$i.$v,.[-<[<<<]+[>>>]<<] @v ; set error flag. print and move to ascii value of variable left
            $c [<<<]>                               ; move to array
            [-<<<<+>>>>>>[>>>] @z                   ; copy n to p and c-1
                    $p + $e[-] $c[<<<]>             ; plus reset error flag
                ]                                   ; end copy
            <<<<[->>>>+<<<<]>>>>>>[->>>] @z         ; restore original value
          $t] $w                                    ; in @ end
      ]$t [- $i.$p+$t ] $w                          ; in > adjusts pos
      ]$t [- $i. $a+$p[-$a-]<[-<]@w $t ] $w         ; in < adjusts pos. Make sure we don't go below 0.
    ]$t [[,----------]++++++++++.[-]] $w            ; in ; removes comment
   ]$t [-                                           ; in :
            $i.$v,.[-<[<<<]+[>>>]<<] @v             ; move to ascii value of variable left

            error checking code for double assignment
            $c[<<<]>[                               ; move to n(i) check if non zero
              >>[>>>]@z $e+ $c[<<<]>                ; when non zero go to e and set 1 (: error)
            [-]]>>[>>>]@z                           ; back to z

            $g+[- $t+ $c[<<<]>+>>[>>>] @z >]        ; increment g and copy g to t and n
            $c [<<<]>>>[->>>] @z                    ; clear trail
            $t [- $g+ $t]                           ; restore new g
     $t]$w                                          ; in : end
  ]$t [                                             ; move to a ($)
            $i.[-]$v,.[-<[<<<]+[>>>]<<] @v          ; move to ascii value of variable left
            $c [<<<]>                               ; if zero it is not defined.
            [-<<<<+>>>>>>[>>>] @z                   ; copy v to c-1 ...
              $i + $a + $c [<<<]>]                  ; i and a
            <<<<[->>>>+<<<<]>>>>>>[->>>] @z         ; restore original value
            <++++++[->++++++++++<]                  ; 60 in z (<)

            error checking is i 0 set e to 2 t is still 1
            $i[-$t-$a-
            ; we have new position in i and old in p
            $w+$p[ $a [-$w-]<[@w-
                $p[-$z.$p] + $t] $w+$p-]            ; a is smaller than p, eg. <
            $z++$w-$a[-$z.$a]$z[-]
            $i[-$p+$i]                              ; set current position

            $t]>[@t$e++$t->]@w                      ; set error flag if t is not set
  $t] $w
 ]$t [- remove var
        $e+++$i.[-]$g                               ; prnit and reduce g
        $v,.[-<[<<<]+[>>>]<<] @v                    ; read and move to ascii value of variable left
        $c [<<<]>                                   ; if zero it is not defined.
        [->>[>>>] @z $t + $e [-] $c [<<<]>]         ; copy n to w
        >>[->>>]@z                                  ; restored
        $t[-$i+$g-$t]                               ; copy to i while re4ducing both g and t
        $g[$e++++$i[-]$g[-]]                        ; t is 0 if g is not 0 we have error
        $i[-$g+$i]                                  ; restore g
$t]                                                 ; end !
check for error
$t+                                                 ; set flag
$e[
    >+++++++++[->++++++++<]>---                      ; prints ERROR using previous block
    .+++++++++++++..---.+++.                         ; and both previous and cuurent block is zero after

    we probably want support for individual         ; 1=:, 2=$, 3=!, 4=@
    error messages in the future

    $i[-]$t-$e[-]                                    ; remove flag
]
$t[-                                                ; if flag set (no error)
$i[-]
read another byte and exit if EOF
$i[-]$t+$i,+[-$t-]                                  ; in $i or $t (compiler thinks $t)
$w[- t >]@w $t] $i ]                                ; loop until read EOF == 0/ -1/ no change




