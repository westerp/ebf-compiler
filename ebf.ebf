;[
; $Id$
; an extended brainfuck to pure brainfuck compiler
; for documentation, please go to http://sylwester.no/ebf/
;
; ebf-compiler is free software: you can redistribute it and/or modify
; it under the terms of the GNU General Public License as published by
; the Free Software Foundation, either version 3 of the License, or
; (at your option) any later version.
;
; ebf-compiler is distributed in the hope that it will be useful,
; but WITHOUT ANY WARRANTY; without even the implied warranty of
; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
; GNU General Public License for more details.
;
; You should have received a copy of the GNU General Public License
; ]

ML|crumble|variable|macro|zero|global|input|tmp|working|adding|position|error
PTR=1277|3 ; this actually allocates variable 3 but nothing changes since we start with @z

start stack structure
:r macro return address stack
:b bracket stack
:d stack marker

start array structure
:c array crumble
:v variable value
:m macro
end array structure

:z zero indicates end of array
:g global variable index
:i input
:t temporary must be next to w
:w working must be between t and a
:a adding aide mus be next to w
:p position eg the current location
:e error number
:o overflow flag expect at after this

>>>++                                               ; 2 stacks of 256 elements
(-<++++(-<++++++++))<<-                             ; multiplied by 32 and then reduced by 1
[->>>>>>>[>>>>>>>>]+[<<<<<<<<]>]                    ; 8*63 = 504+8
>>>>>>>[->>>>>>>>]                                  ; goto 512
<<<->>>                                             ; set -1

>>>+++                                              ; number of variables in array
(-<++++(-<++++++++))<<-                             ; multiplied by 32 and then reduced by 1
[->>>>>>>[>>>>>>>>]+[<<<<<<<<]>]                    ; multiplied by 8 cells = 760 (3 elements)
>>>>>>>[->>>>>>>>]                                  ; goto 768
@z ; indicates that we are on m
$o+
$i ,(                                               ; outer loop. EOF=0

; copy $i to $w
(- $t+ $w+)                                         ; pour $i to $w and $t
$t(- $i+)                                           ; pour $t to $i
+                                                   ; i=I|t=1|w=I|p=x
; switch
$a +++(- $w -----------)                            ; reduce $w with 3*11=33(!)
 $w (---                                            ; no, reduce $w with 3($)
     (----                                          ; no  reduce $w with 4 "("
      (-                                            ; no  reduce $w with 1 ")"
       ( $a++++(- $w---- ) $w-                      ; no, reduce $w with 17(:)
        ( -                                         ; no, reduce by 1 (;)
         ( -                                        ; no, reuce by 1 (<)
          ( --                                      ; no, reuce by 2 (>)
           ( --                                     ; no, reduce by 2 (@)
            ((-) $i . $t- )                         ; reset $t and $w
           $t (-                                    ; in @
                $o(-)+$e++++$p(-)-$i.$v,.           ; set error flag. print input, read input to v and output
                $v(-$c(@z)+@z(@c))                  ; open path to array index like input
                $c(@z)                              ; move to array value
                $v(- $c@z$c + $z@c$v $z(@c)         ; copy n  to c-1 ...
                    $p + $e(-) $c(@z)               ; p and reset error flag
                )                                   ; end copy
                $c@z$c(-$z@c$v+$c@z)$z@c$v          ; restore original value
                $z(@c-)                             ; close array
              )                                     ; in @ end
          )$t (- $i.$a+$p+[$a-]$w[@a-$o(-)$w] )     ; in > adjusts pos
        )$t (- $i. $a+$p[-$a-]$w[@a-$o(-)$w] )      ; in < adjusts pos. Make sure we don't go below 0.
       )$t ((,----------)++++++++++.(-))            ; in ; removes comment
      )$t (-                                        ; in :
            $i.$v,.                                 ; print input, read input to v and output
            $v(-$c(@z)+@z(@c))                      ; open path to array index like input

            error checking code for double assignment
            $c(@z)@c$v((-)                          ; move to n(i) check if non zero
              $z@z(@c) $e+ $c(@z)@c)                ; when non zero go to e and set 1 (: error)
            $z@z(@c)                                ; back to z

            $g+(- $t+ $c(@z)@c$v+$z(@c) )           ; increment g and copy g to t and n
            $c(@z)$z(@c-)                           ; clear trail
            $t(- $g+)                               ; restore new g
          )                                         ; in : end
     )$t (- close bracket                           ; in ")"
           $o((-)
           $i(-)                                    ; we need i
           $w-$t+[-<+]--
           <<<[<<]->>
           [-
             [>>]+[->+]-@w
             $a+$i+
             +[-<+]->>
           ]
           <<+++[-->++]-                            ; restore mark from -2 to -1
           [>]+[->+]@w

           $z<++++++[->++++++++++<]                  ; 60 in z (<)
           $t+
            error checking is i 0 set e to 2 t is still 1
            $i[-$t-$a-
            ; we have new position in i and old in p
            $w+$p[ $a [-$w-]<[@w-
            $p[-$z.$p] + $t] $w+$p-]                ; a is smaller than p, eg. <
            $z++$w-$a[-$z.$a]$z(-)
            $i[-$p+$i]                              ; set current position
            $t]>[@t$e+++++$t->]@w                   ; set error flag if t is not set
            +++++++[-$t+++++++++++++$w]$t++.        ; print "]"
            (-)                                     ; blank out w
            )+$i(.(-)$e+)
          )                                         ; end ")"
    )$t (  open bracket                             ; in "("
            ++++++(-$i+++++++)$i++.                 ; convert "(" to "[" by adding 51
            $a-$w+[-<+]-@d                          ; seek to -1
            $b @r(@d) +                             ; mark
            @d(@r)+[->+]-@a                         ; first zero, then first -1

            $p(-$w++[-<+]-@d
                $b @r(@d) $d+
                @d(@r)+[->+]-@a                     ; first zero, then first -1
              )
            $a+$w(-$p+)
        )                                           ; end "("
   )$t (                                            ; move to a ($)
            $i.(-)$v,.                              ; print and zero input, read input to v and output
            $v(-$c(@z)+@z(@c))                      ; open path to array index like input
            $c(@z)                                  ; if zero it is not defined.
            $v(- $c@z$c+ $z@c$v@v$z @z(@c)          ; copy v to c-1 ...
              $i + $a + $c(@z) )                    ; i and a
              $c@z$c(-$z@c$v+$c@z)$z@c$v@v          ; restore original value
              $z(@c-)                               ; close array
            <++++++(->++++++++++)                   ; 60 in z (<)

            error checking is i 0 set e to 2 t is still 1
            $i[-$t-$a-
            ; we have new position in i and old in p
            $w+$p( $a [-$w-]<[@w-
                $p[-$z.$p] + $t] $w+$p-)            ; a is smaller than p, eg. <
            $z++$w-$a(-$z.)$z(-)
            $i(-$p+)                                ; set current position

            $t]>[@t$e++$t->]@w                      ; set error flag if t is not set
        )
 )$t (- remove var
        $e+++                                       ; set error flag
        $i.(-)$v,.                                  ; print and zero input, read input to v and output
        $v(-$c(@z)+@z(@c))                          ; open path to array index like input
        $c(@z)                                      ; if zero it is not defined.
        $v(- $z(@c) $t + $e (-) $c(@z) )            ; copy n to w
        $z(@c-)                                     ; close array
        $t(-$i+$g-)                                 ; copy to i while re4ducing both g and t
        $g((-)$e++++$i(-))                          ; t is 0 if g is not 0 we have error
        $i(-$g+)$g-                                 ; restore g
     )                                              ; end !
check for error
$t+                                                 ; set flag
$e(
    $t++++++++(-$w++++++++)$w---                    ; prints ERROR using previous block
    .+++++++++++++..---.+++.                        ; and both previous and cuurent block is zero after
    (-)++++++++++.
    we probably want support for individual         ; 1=:, 2=$, 3=!, 4=@
    error messages in the future

    $i(-)$e(-)                                      ; remove flag
    -<+[-<+]-<(-)<(-)>>>+[->+]@e
)
$t(-                                                ; if flag set (no error)
$i(-)
read another byte and exit if EOF
$i(-)$t+$i,+[-$t-]                                  ; in $i or $t (compiler thinks $t)
$w[- t >]@w ))                                      ; loop until read EOF == 0/ -1/ no change

; need to check stack for uneven brackets
+[-<+]<
    [
    >>+++++++++[->++++++++<]>---                    ; prints ERROR using previous block
    .+++++++++++++..---.+++.                        ; and both previous and cuurent block is zero after
    (-)++++++++++.(-)
]



