;[
; $Id$
; an extended brainfuck to pure brainfuck compiler
; for documentation, please go to http://sylwester.no/ebf/
;
; ebf-compiler is free software: you can redistribute it and/or modify
; it under the terms of the GNU General Public License as published by
; the Free Software Foundation, either version 3 of the License, or
; (at your option) any later version.
;
; ebf-compiler is distributed in the hope that it will be useful,
; but WITHOUT ANY WARRANTY; without even the implied warranty of
; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
; GNU General Public License for more details.
;
; You should have received a copy of the GNU General Public License
; ]

ML|crumble|variable|macro|zero|global|input|tmp|working|adding|position|error
PTR=1277|3 ; this actually allocates variable 3 but nothing changes since we start with @z

start array structure
:c array crumble
:v variable value
:m macro
end array structure

:z zero indicates end of array
:g global variable index
:i input
:t temporary must be next to w
:w working must be between t and a
:a adding aide mus be next to w
:p position eg the current location
:e error number

>>>++                                               ; 2 stacks of 256 elements
[-<++++[-<++++++++>]>]<<-                           ; multiplied by 32 and then reduced by 1
[->>>>>>>[>>>>>>>>]+[<<<<<<<<]>]                    ; 8*63 = 504+8
>>>>>>>[->>>>>>>>]                                  ; goto 512
<<<->>>                                             ; set -1

>>>+++                                                ; number of variables in array
[-<++++[-<++++++++>]>]<<-                           ; multiplied by 32 and then reduced by 1
[->>>>>>>[>>>>>>>>]+[<<<<<<<<]>]                    ; multiplied by 8 cells = 760 (3 elements)
>>>>>>>[->>>>>>>>]                                  ; goto 768
@z ; indicates that we are on m

$i ,[                                               ; outer loop. EOF=0

; copy $i to $w
[- $t+ $w+ $i ]                                     ; pour $i to $w and $t
$t [- $i+ $t  ]                                     ; pour $t to $i
+                                                   ; i=I|t=1|w=I|p=x
; switch
$a +++[- $w ----------- $a]                         ; reduce $w with 3*11=33(!)
 $w [---                                            ; no, reduce $w with 3($)
     [----                                          ; no  reduce $w with 4 "("
      [-                                            ; no  reduce $w with 1 ")"
       [ $a++++[- $w---- $a ] $w-                   ; no, reduce $w with 17(:)
        [ -                                         ; no, reduce by 1 (;)
         [ -                                        ; no, reuce by 1 (<)
          [ --                                      ; no, reuce by 2 (>)
           [ --                                     ; no, reduce by 2 (@)
            [ $i . $t- $w [-] ]                     ; reset $t and $w
           $t [-                                    ; in @
                $e++++$p[-]-$i.$v,.                 ; set error flag. print input, read input to v and output
                [-$c[@z$c]+[@c$z]@z$v]              ; open path to array index like input
                $c [@z$c]@c$v                       ; move to array value
                [- $c@z$c + $z@c$v @v$z[@c$z] @z    ; copy n  to c-1 ...
                    $p + $e[-] $c[@z$c]@c$v         ; p and reset error flag
                ]                                   ; end copy
                $c@z$c[-$z@c$v+$c@z$c]$z@c$v        ; restore original value
                $z[@c - $z]@z                       ; close array
          $t] $w                                    ; in @ end
         ]$t [- $i.$p+$t ] $w                       ; in > adjusts pos
        ]$t [- $i. $a+$p[-$a-]<[-<]@w $t ] $w       ; in < adjusts pos. Make sure we don't go below 0.
       ]$t [[,----------]++++++++++.[-]] $w         ; in ; removes comment
      ]$t [-                                        ; in :
            $i.$v,.                                 ; print input, read input to v and output
            [-$c[@z$c]+[@c$z]@z$v]                  ; open path to array index like input

            error checking code for double assignment
            $c[@z$c]@c$v[                           ; move to n(i) check if non zero
              $z[@c$z]@z $e+ $c[@z$c]@c$v           ; when non zero go to e and set 1 (: error)
            [-]]$z[@c$z]@z                          ; back to z

            $g+[- $t+ $c[@z$c]@c$v+$z[@c$z] @z $g]  ; increment g and copy g to t and n
            $c [@z$c]$z[@c - $z] @z                 ; clear trail
            $t [- $g+ $t]                           ; restore new g
     $t]$w                                          ; in : end
     ]$t [- #close bracket                          ; in ")"
           $i[-]                                    ; we need i
           $w-$t+[-<+]--
           <<<[<<]->>
           [-
             [>>]+[->+]-@w
             $a+$i+
             +[-<+]->>
           ]
           <<+++[-->++]-                            ; restore mark from -2 to -1
           [>]+[->+]@w

           $z<++++++[->++++++++++<]                  ; 60 in z (<)
           $t+
            error checking is i 0 set e to 2 t is still 1
            $i[-$t-$a-
            ; we have new position in i and old in p
            $w+$p[ $a [-$w-]<[@w-
            $p[-$z.$p] + $t] $w+$p-]                ; a is smaller than p, eg. <
            $z++$w-$a[-$z.$a]$z[-]
            $i[-$p+$i]                              ; set current position
            $t]>[@t$e+++++$t->]@w                   ; set error flag if t is not set
            +++++++[-$t+++++++++++++$w]$t++.        ; print "]"
            [-]                                     ; blank out w
            $t
         ] $w                                       ; end ")"
    ]$t [- open bracket                             ; in "("
            +++++++[-$i+++++++$t]$i++.              ; convert "(" to "[" by adding 51
            $a-$w+[-<+]-                            ; seek to -1
            <[<<]+                                  ; mark
            [>>]+[->+]-@a                           ; first zero, then first -1

            $p[-$w++[-<+]-
                <[<<]>>+
                [>>]+[->+]-@a                       ; first zero, then first -1
                $p]
            $a+$w[-$p+$w]
            $t
        ] $w                                        ; end "("
   ]$t [                                            ; move to a ($)
            $i.[-]$v,.                              ; print and zero input, read input to v and output
            [-$c[@z$c]+[@c$z]@z$v]                  ; open path to array index like input
            $c [@z$c]@c$v                           ; if zero it is not defined.
            [-$c@z$c+$z@c$v@v$z[@c$z] @z            ; copy v to c-1 ...
              $i + $a + $c [@z$c]@c$v]              ; i and a
              $c@z$c[-$z@c$v+$c@z$c]$z@c$v@v        ; restore original value
              $z[@c - $z] @z                        ; close array
            <++++++[->++++++++++<]                  ; 60 in z (<)

            error checking is i 0 set e to 2 t is still 1
            $i[-$t-$a-
            ; we have new position in i and old in p
            $w+$p[ $a [-$w-]<[@w-
                $p[-$z.$p] + $t] $w+$p-]            ; a is smaller than p, eg. <
            $z++$w-$a[-$z.$a]$z[-]
            $i[-$p+$i]                              ; set current position

            $t]>[@t$e++$t->]@w                      ; set error flag if t is not set
  $t] $w
 ]$t [- remove var
        $e+++                                       ; set error flag
        $i.[-]$v,.                                  ; print and zero input, read input to v and output
        [-$c[@z$c]+[@c$z]@z$v]                      ; open path to array index like input
        $c [@z$c]@c$v                               ; if zero it is not defined.
        [-$z[@c$z] @z $t + $e [-] $c [@z$c]@c$v]    ; copy n to w
        $z[@c - $z]@z                               ; close array
        $t[-$i+$g-$t]                               ; copy to i while re4ducing both g and t
        $g[$e++++$i[-]$g[-]]                        ; t is 0 if g is not 0 we have error
        $i[-$g+$i]$g-                               ; restore g
$t]                                                 ; end !
check for error
$t+                                                 ; set flag
$e[
    $t++++++++[-$w++++++++$t]$w---                  ; prints ERROR using previous block
    .+++++++++++++..---.+++.                        ; and both previous and cuurent block is zero after
    [-]++++++++++.
    we probably want support for individual         ; 1=:, 2=$, 3=!, 4=@
    error messages in the future

    $i[-]$e[-]                                      ; remove flag
]
$t[-                                                ; if flag set (no error)
$i[-]
read another byte and exit if EOF
$i[-]$t+$i,+[-$t-]                                  ; in $i or $t (compiler thinks $t)
$w[- t >]@w $t] $i ]                                ; loop until read EOF == 0/ -1/ no change

; need to check stack for uneven brackets
+[-<+]<
    [
    >>+++++++++[->++++++++<]>---                    ; prints ERROR using previous block
    .+++++++++++++..---.+++.                        ; and both previous and cuurent block is zero after
    [-]++++++++++.[-]
]



