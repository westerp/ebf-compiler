;[
; $Id$
; an extended brainfuck to pure brainfuck compiler
; for documentation, please go to http://sylwester.no/ebf/
;
; ebf-compiler is free software: you can redistribute it and/or modify
; it under the terms of the GNU General Public License as published by
; the Free Software Foundation, either version 3 of the License, or
; (at your option) any later version.
;
; ebf-compiler is distributed in the hope that it will be useful,
; but WITHOUT ANY WARRANTY; without even the implied warranty of
; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
; GNU General Public License for more details.
;
; You should have received a copy of the GNU General Public License
; ]

ML|crumble|variable|macro|zero|global|global_macro|8bit|hash|input|tmp|working|adding|position|error|nooverflow|macro_number|flag|zero|macro_area|input_area|tmp|wrk
PTR=1285|3

; #########################################################################################
; MACRO DEFINITIONS

; stack_error prints out ERROR if stack set
; It is used in the end of the application
{print_if_stack_error
    $z+[-<+]<
    [                                   ; need to check stack for uneven brackets
        >>+++++++++[->++++++++<]>---    ; prints ERROR using previous block
        .+++++++++++++..---.+++.        ; and both previous and cuurent block is zero after
        (-)++++++++++.(-)
    ]
}

; macro for implementing the > which increases the pointer or
; resets overflow. for normal operation overflow is always set
{go_up $i.$a+$p+++[$a-]$w[@a-$o(-)$p-$w]$p-- }

; macro for implementing the < which decreases the pointer or
; resets overflow. for normal operation overflow is always set
{go_down $i. $a+$p[-$a-]$w[@a-$o(-)$w] }

; implements removal of comments. Because of the newline we don't reuse this
{rm_comment (,----------)++++++++++.(-) }                    ; purge comments

; auto alighning bracket. ( is the one of two '(' and ')' where ( sets a stack
; to the position it is nowe and print out a Â [.
{open
    $o((-)
    $t+++++++(-$i+++++++)$i++.(-) ; convert "(" to "[" by adding 51
    $a-$w+[-<+]-@d                ; seek to -1
    $b @r(@d) +                   ; mark
    @d(@r)+[->+]-@a               ; first zero, then first -1

    $p(-$w++[-<+]-@d
        $b @r(@d) $d+
        @d(@r)+[->+]-@a           ; first zero, then first -1
        )
    $a+$w(-$p+)
    )+$i(.(-)$e+)
    open brackets end
}

{macrun
  push position on stack
    $a-$w+[-<+]-@d                ; seek to -1
    $r @r(@d) +                   ; mark
    @d(@r)+[->+]-@a               ; first zero, then first -1

    $p(-$w++[-<+]-@d
        $r @r(@d) $d+
        @d(@r)+[->+]-@a           ; first zero, then first -1
        )
    $a+$w(-$p+)
    macrun end
}

{macrend
  remove position on stack
    $a-$w+[-<+]-@d                ; seek to -1
    $r @r(@d) $d(-)               ; delete
    @r$d(@r)+[->+]@a              ; move back
  macrend end
}

{param #
  move to position in stack
  with possible numeric operand for offset indication
  $w-$t+[-<+]--@d                 ; seek to -1 set to -2
  $r (@d) -                       ; delete set -1
  $d                              ; tmp|-1|x....
  [ [->+]-@w                      ; reduce
    $a+$i+
    +[-<+]-
    <<+>>>> ]
  <<+<<@r(->>>>+)                 ; restore stack
  [>>]<<+                         ; retore marker from -2 to -1
  [->+]@w
  &posmove
}
; auto alighning bracket. ) is the second of two '(' and ')' where ) pops the stack
; and creates the command to move to that location before changing ) to a ]
{close
    $o((-)
    $i(-)                we need i
    $w-$t+[-<+]--        move backwards to stack ; -1 set to -2
    <<<[<<]->>           move along stack area until zero; set it to -1
    [-                   pour stack element to a and i
        [>>]+[->+]-@w
        $a+$i+
        +[-<+]->>
    ]
    <<+++[-->++]-        reset stack element mark and restore stack mark; from -2 to -1
    [>]+[->+]@w

    $z<++++++[->++++++++++<]  60 in z ; (<)
    $t+
    error checking is i 0 set e to 2 t is still 1
    $i[-$t-$w+$a-
        we have new position in i and old in p
        $p(- $a [-$w-]<[@w-
        $p+(-$z.) $t] $w+$p)    a is smaller than p; eg. <
        $z++$w-$a(-$z.)$z(-)
        $i(-$p+)                set current position
    $t]>[@t$e+++++$t->]         set error flag if t is not set
    $w+++++++(-$t+++++++++++++)$t++. print close ; eg. "]"
    (-)                         blank out w
    )+$i(.(-)$e+)               set error if e set
    close bracket end
}

; implements the (:). It defines a variable in pretty much the same
; way it defines a macro_area but justs leave it at that. If you redefine
; already existing array you will get ERROR
{var_create
    define new variable start
;    $i. &i $v.           readprint i and v
    &array_open                   open path to array index like input

    error checking code for double assignment
    &array_element                   go to array
    $v((-) &array_back $e+ &array_element)    when v i set then set e
    &array_back                   go from array

    $g+(- $t+            copy incremented g
       &array_element $v+            to t_backup and var location
       &array_back )              go back
    &array_element&array_close                 close array
    $t(- $g+)            restore g
    define variable end
}

; implements the ($). It creates the brainfuck code to move from the current
; position to that position. Trying to move to a prosition not defined with :
; prints ERROR.
{var_move
    $e+                                         ; set error
    $o((-)
    $e(-)                                       ; zero input,

;   read print to v &i $v.                      ; read finished
    $t+

    &array_open                      ; open path to array index like input
    &array_element                                  ; if zero it is not defined.
    $v(- &B+ &F@v$z @z(@c)          ; copy v to c-1 ...
        $i + $a + &array_element )                    ; i and a
        &B(-&F+$c@z)&F@v          ; restore original value
        &array_close                               ; close array
      &posmove
    )+
    variable position end
}


; Assumes we have a position in i and a
; where we want to move and create < and >
; to do so. Used by both varmove and param 
{posmove
    $z<++++++(->++++++++++)                   ; 60 in z (<)

    error checking is i 0 set e t is still 1
    $i[-$t-$w+$a-
    ; we have new position in i and old in p
    $p( $a [-$w-]<[@w-
        $p[-$z.$p] + $t] $w+$p-)            ; a is smaller than p, eg. <
    $z++$w-$a(-$z.)$z(-)
    $i(-$p+)                                ; set current position

    $t]>[@t$e+$t->]@w                       ; set error flag if t is not set
}


; implements the at (@). After an uneven loop you may use @ to
; indicate where amoungst the variables the  applicatuion is.
; trying to indicate a non existing variable will induce ERROR
; reading this code you see that it is also used to simplify
; some code by using the same variable structure somewhere else
; than it's original location.
{var_position_set
    $o(-)+      set overflow
    $e+$p(-)-   set error and p to 255
    &array_open &array_element       open and go to array value
    $v(-        copy v
     &B + &F    to backup
     &array_back         move from array
      $p + $e(-)and to p and reset e
     &array_element         move to array
    )           end copy

    restore backup
    &B(-
      &F+$c@z
    )&F

    &array_close         close array
    set position end
}

; implements the (!). Deletes a variable defined with (:). It HAS to be
; the last variabel created and need to be defined. Failing both these
; criterias will induce ERROR. I have never actually used this, but the
; though was to create variables and delete them at will.
{var_delete                   delete  variable
        $e+                   set error
        &array_open &array_element                 open path and goto array location
        $v(-                  copy v to
            &array_back $t + $e(-)     t and reset e
            &array_element )
        &array_close                    close array
        $t(-$i+$g-)           copy to i while reducing both g and t
        $g((-)$e+$i(-))       t is 0 if g is not 0 we have error
        $i(-$g+)$g-           restore g
}

; implements macro definition ({). It has an macro index that gets incremented
; for each one and that is tsored in the macro names index. it is just appended
; to the end where the next macro (or input buffer) should be. It moves the
; input bufer accordingly. It is not allowed to define macroes inside macroes and
; therefor you will never have input in buffer when in this part of the code.
{macro_create
    &array_open                  open path to array index like input

    error checking code for double assignment
    &array_element$m((-)            move to variable check if non zero
    &array_back $e+ &array_element)          when non zero set e ; ERROR
    &array_back                  back to z

    $G+(- $t+ &array_element$m+&array_back ) increment G and copy g to t and n
    &array_element&array_close                clear trail
    $t(- $G+)           restore new G

    there is always a ~1 where input starts and its to the right of where macro should have its first char
    lets copy h there
    $h(- $t->+[->+]-<++[-<+]@t )
    $t+[->+]
    |B|F|Z|test|0|0|test2|0|0|0|~1
;    $M>>[[>]>>>]
;    >(-)                remove marker
    @t to make this easy we assume we are at t
    $t+$i[$t-]>(@t-$i,)
    $t+$i(
        $t+++++++(-$i-------)+$i---          reduce by 59;  (;)
        (>+++++++(-<--------)+<              reduce by 64;  ({)
            (--                              reduce by 2 ;  (})
            ( restore by increase of 125
                $t++++++++++(-$i+++++++++++) increase 121
                $i++++>@i                    inc 4 == 125
                $w+
            )$t (-                           in close macro ;eg }
                $i(-)$t+
                h=char|i=0|t=1|w=0
                $h[>]
                >(-)
                >(@i no char in macro error
                  [--<++]--@M               go back to ~2
                  $e++[->+]@t
                )
            )
            )$t(-                            in open macro which
                $i(-)                        is an error since
                -<++[--<++]--@M              a macro definition cannot
                $e+++$M>>[[>]>>>]@i            contain another macro definition
            )
        )$t(-                   in comment ignore everything until cr; (;)
            $i+(,----------)    read until cr
            ++++++++++
            >@i
            $w+
        )
        $w(-$t+$i,              continue reading if w is set
            +[-$t-]$w[@t-$w]    check eof
            $t+                 set t for next run
        )
    )>>>>                       set new buffer marker
    +[--<++]--@M                go back to ~2
    end macro open tag
}

; implements macro expansion (&). It will lookup the index value from the macro name
; and move to the end of that macro index and create a mark (-1). It will then copy backwards
; 0|macrocontents|-1|0|0| => 0|-1|macrocontents|0|0|..(other macroes)...-2|previous content|stnetnocorcam|0|-1
; then it will crean up so that we have the same structure only with added content in buffer
; -2|0|macrocontents|0|0|0|..(other macroes)...-1|previous content|stnetnocorcam|0...
{run_macro

    since macro will add to buffer and everything in hash is an intermidiate cache we need to move hash
    to the buffer so it does not get processed first
    $i+$h(
        move position to error
        $p(-$e+)
        $i+++++++                             set 8 in the cell next to data
        <[->-[>+>>]>[+[-<+>]>+>>]<<<<<]@h     divids input with 8
        after h=0 i=any t=n%d w=n/d
        this assumes t w and a and e are 0
        $i(-)->+[->+]-- set I to ~2
        [>]>- set first byte to the right of input to ~1
        <+[-<+]-@i
        $t(
            [->+]-    reduce by 1 and move to the byte after input
            <+        increase 1s
            +[-<+]-@i back to i
         )
         $i+$t-
        $w(
            [->+]-    reduce by 1 and move to the byte after input
            <++++++++ increase 8s
            +[-<+]-@t back to t
         )
         +[->+]++          move to and set the byte after input to 2 eg end of macro
         ++[--<++]-     reset I to ~1
         <+[-<+]@t      reset t to 0
         $e(-$p+) restore position
    )
    $i(- special case where h is not set
      +[->+]-        goto start of input
      [>]++           set it to 1 eg end of macro
      ++[--<++]--@M  go back to M
    )
    $e+

    &array_open                      ; open path to array index like input
    &array_element                      ; move to array value
    $m(- &B + &F &array_back         ; copy n  to c-1 ...
        $Z +  &array_element            ; Z and reset error flag
    )                       ; end copy
    &B(-$z@c$m+$c@z)&F      ; restore original value
    &array_close                      ; close array

    $Z($e(-)$Z-(- $I>
        [[>]>>]<<+++[--<++]--@M
        )
    $I >[[>]>>]<<->>>                       ; set first zero to 255
    [[>]>>>]                                ; move to last element
    +>[<-
        >-[>]>-<<[<]                        ; set next byte to input to 255.. we now have M=255|......|0|macrocontents|255|0|0|......|contentstart=254|.....|0|255.
    ]<[-
        >-->>-<<<<
    ]
    +[-<+]-
    <[
        [->>++[->+]-<++[-<+]-<]             ; copy byte to next byte and end of buffer
        >>+[->+]>-<+[-<+]<-<]               ; move 255 to new open space and repeat |0*|0|255|macrocontents|0|nextmacro
    >+>>[ [-<<+>>]>]                        ; copy back to |0*|macrocontents|0|0|0|nextmacro
    <<->+[->+]++[--<++]-<+[-<+]             ; seek back to current array macro_area
    +[-<[<]<<]@Z)

    +[->+]-        goto start of input
    [>]+           set it to 1 eg start of macro
    ++[--<++]--@M  go back to M

    do macro end
}

; read from left char or use read buffer function
{i
        $h(-$v+)
        $m+$v[$m-]$z
        (@m-
        &I
        )

}

; read from buffer. If buffer is empty read from stdin. does not check for EOF
; it seeks to -1, change it to -2. Then moves to the left until a empty cell is
; reached. This is  then marked with -1 and th eprevious cell will be copied back
; to the main variable area using -1 marks. removes the -1 and restores the -2 to -1
; before returning.
{I
        read input to v and output
        $t->+[->+]-->                       set 255 to t then move to first 255 on the right set to 254 move right
        [[>]                                move right until 0 to the right of data

        optimized by dividing input with 8 and moving 8s to v
        then the remainder so that copy takes fewer moves across data
        avg data is 67 so on average we move 7 times to increse 8
        then 3 giving a total of 10 rounds instead of 66
        ++++++++                            set 8 in the cell next to data
        <[->-[>+>>]>[+[-<+>]>+>>]<<<<<]     divids input with 8
        after 0=0 1=positive 2=n%d 3=n/d
        >>>>-<                              mark 255
        [- <+[-<+]-@t$v++++++++$w+[->+]-<]  copy result of div from input to v mul 8
        >+<-<
        [- <+[-<+]-@t$v+$w+[->+]-<]         copy remainder from from input to v
        >+<<[-]<                            cleanup
        ]

        ++[--<++]-<                         move to 254 marker set to 255
        +[-<+]@t                            move to t and reset input is in i
        $m+$v[$m-]$z                        check if v is set
        [@m- $v, $z]                        if then we read from stdin

        $m+$v+[-$m-]$z                      convert ~1 to 0
        [@m-$z]
}

; Often used macroes and because of speed moved
; closer to the buffer.

; Open array path. It expects v to contain a ascii and will
; tag the bread crumb until they are at that ascii values
; position.
{array_open      $v(-$c(@z)+@z(@c))                          open array path
}
; Rerset array. Must be at the furthest set bread crumb and will
; remove that flag on it's way to zero.
{array_close     $z(@c-)                                     reset array
}
; Crumble. Will move crubles until the first 0 is met. This is
; by definition the active array element
{array_element   $c(@z)                                      move left
}
; Zero. Same as Cruble but reverse. It moves from array
; to variable position
{array_back      $z(@c)                                      move right
}
; Back and Forward. Used to backup any value in array to be restored after copy.
{B      $c@z$c }; backward to copy
{F      $z@c$v }; forward from copy

; End macro definitions
; ###########################################################################
; ############################################################################

start stack structure
:r macro return address stack
:b bracket stack
:d stack marker

start array structure
:c array crumble
:v variable value
:m macro
end array structure

:z zero indicates end of array

:g global variable index
:G global macro index

:8 zero if 8 bit
:h hash

:i input
:t temporary must be next to w and i
:w working must be between t and a
:a adding aide must be next to w
:p position eg the current location
:e error number
:o overflow flag expect at after this
:Z zero

macros area
:M Macro area

input area with bytes written from ne or more macros
:I Input area

>>>++                                               ; 2 stacks of 256 elements
(-<++++(-<++++++++))<<-                             ; multiplied by 32 and then reduced by 1
[->>>>>>>[>>>>>>>>]+[<<<<<<<<]>]                    ; 8*63 = 504+8
>>>>>>>[->>>>>>>>]                                  ; goto 512
<<<->>>                                             ; set -1

>>>+++                                              ; number of variables in array
(-<++++(-<++++++++))<<                              ; multiplied by 32
[->>>>>>>[>>>>>>>>]+[<<<<<<<<]>]                    ; multiplied by 8 cells = 760 (3 elements)
>>>>>>>[->>>>>>>>]                                  ; goto 776
@z ; indicates that we are on z
;$h++++++++(-$8(-$G++)$G+(-$8+))                     ; stores 255 in 8
$h++++++(-$G++++++(-$8+++++++))$8-                  ; stores 251 in 8
$o+$M-->>>-
$v ,(                                               ; outer loop. EOF=0

(- $t+ $w+)                                         ; pour $i to $w and $t
$t(- $i+)                                           ; pour $t to $i
+                                                   ; i=I|t=1|w=I|p=x
; switch
$w-                                                 ; reduce $w by 1 (start of macro expanded)
  (-                                                ; no, reduce by 1 (end of macro expanded)
   (-$a+++(- $w ----------)$w                       ; reduce $w with -1-3*10=33(!)
    (---                                            ; no, reduce $w with 3($)
     (--                                            ; no, reduce $w with 2 (&)
      (--                                           ; no  reduce $w with 2 "("
       (-                                           ; no  reduce $w with 1 ")"
        ( $a++++(- $w---- ) $w-                     ; no, reduce $w with 17(:)
         ( -                                        ; no, reduce by 1 (;)
          ( -                                       ; no, reuce by 1 (<)
           ( --                                     ; no, reuce by 2 (>)
            ( --  #                                  ; no, reduce by 2 (@)
             ( $a+++(- $w----------) $w             ; no, reduce by 30 (^)
              ( $a+++(- $w----------) $w+           ; no, reduce by 29 ({)
               ((-) $i . $i(-) $t- )                ; reset $t and $w
               $t (- macro      $i+++.(-)+  )       ; in {, output ~, set 1 in i
              )$t (- $i.(-) &param          )       ; in ^, move to call position
             ) $t (- at         $i.(-)++    )       ; in @, outpuy @, set 2 in i
            )  $t (- &go_up     $i(-)       )       ; run go_right since > adjusts pos
           )   $t (- &go_down   $i(-)       )       ; run go_left since < adjusts pos
          )    $t (  &rm_comment$i(-)       )       ; in ; removes comment
         )     $t (- set        $i.(-)+++   )       ; in :
        )      $t (- &close     $i(-)       )       ; in ")"
       )       $t (- &open      $i(-)       )       ; in "("
      )        $t (- replace    $i.(-)++++  )       ; in &
     )         $t (- varmove    $i.(-)+++++ )       ; move to a ($) (t is 1)
    )          $t (- delete     $i.(-)++++++)       ; !
   )           $t (- &macrend   $i--        )       ; end of macro
  )            $t (- &macrun    $i-         )       ; macro start


$i( if i is set
- reduce i
 $m+(-
    &I read first variable char
    $v(-$c+$z+) zerocopy v to c and z
    $m++++++(-$z--------) reduce z by 48 ascii 0
    $v+++++++++          set 9 to v
    (>>[-<]<[>]@m$v-)    z sub v
    $m+$z(               set m goto v check set
     this means it is set eg no match for digits
     --------           reduce z by 8 A
     $m++++(-$v+++++)$v set 25 to v
     (>>[-<]<[>]@m$v-)  z sub v
     $m+$z(
      this means it is set eg no match again for upper case letters
      -----              reduce z by 5 _
      (--                check for underscore reduce by 2 ascii a
      $m++++(-$v+++++)$v set 25 to v
      (>>[-<]<[>]@m$v-)  z sub v
      $m+$z(
      this means it is set eg no match against lower case letters
      $m-                reset m
      $z(-)              reset z
  ))))
  if m is set then we matched /\w|_/i
  $m(-
      $e(-)+ set e
      $h(-$w+) move h to w
      $w(-$h++) double h
      $c.-(-$h+) pour c to h
      $z+
    )
    $z(-$m+)
  )

; compatibility notice: if first char did not match matched /\w|_/i we have e set to zero
; this will be an error
$e(-$t+) copy e to t
$w+ set working to 1
$t($w-

implementations with more than 8 bits might have large number
when dealing with long variable names but we do a mod 251
$8(
  $i(-$a+) move i to a
  $8(-$i+)  copy 251 to i
  8|h|i|t|w|a
  $h(-$i-
     [>-]>
       (-@t
        $8(-$i+)-$i+ put 251 back to i
       )
       $t+$8+
       )
   $8(-$i+$v+) move directly to v
   $w+
)
$w(-
 $i(-$8+) restore 251 to 8
 $a(-$i+) restore i
)

hash is now  new input
move hash to v
increase once to make it between 1 and 252
$h+(-$v+)

move c to hash
$c(-$h+)

$i new switch
  (-
   (-
    (-
     (-
      (-$t- &var_delete     )
        $t (- &var_move     )
     ) $t (- &run_macro     )
    ) $t (- &var_create     )
   ) $t (- &var_position_set)
  ) $t (- &macro_create     )
 )
 $w (-$c(-)$e++) set error flag
)
check for error
$t+                                                 ; set flag
$e(
;    ++++++++++++++++++++++++++++++++++++++++++++++++.
    $e(-)$t-$c<+>->(-)>(-)                          ; remove flag. simulate stack at v.
)
$t(-                                                ; if flag set (no error)
read another byte and exit if EOF
&i
$m+$v+   check for ~1
[-$m-]   at eof if in this
$z[@m->] ))                                      ; loop until read EOF == 0/ -1/ no change

&print_if_stack_error
