;[
; $Id$
; an extended brainfuck to pure brainfuck compiler
; for documentation, please go to http://sylwester.no/ebf/
;
; ebf-compiler is free software: you can redistribute it and/or modify
; it under the terms of the GNU General Public License as published by
; the Free Software Foundation, either version 3 of the License, or
; (at your option) any later version.
;
; ebf-compiler is distributed in the hope that it will be useful,
; but WITHOUT ANY WARRANTY; without even the implied warranty of
; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
; GNU General Public License for more details.
;
; You should have received a copy of the GNU General Public License
; ]

ML|crumble|variable|macro|zero|global|global_macro|input|tmp|working|adding|position|error|nooverflow|macro_number|flag|zero|macro_area|input_area|tmp|wrk
PTR=1277|3

; #########################################################################################
; MACRO DEFINITIONS

; prints out ERROR if stack set
{e;              error if stack set
                ; need to check stack for uneven brackets
                $z+[-<+]<
                    [
                    >>+++++++++[->++++++++<]>---                    ; prints ERROR using previous block
                    .+++++++++++++..---.+++.                        ; and both previous and cuurent block is zero after
                    (-)++++++++++.(-)
                ]
}

; macro for implementing the > which increases the pointer or
; resets overflow. for normal operation overflow is always set
{g  $i.$a+$p+++[$a-]$w[@a-$o(-)$p-$w]$p-- }

; macro for implementing the < which decreases the pointer or
; resets overflow. for normal operation overflow is always set
{l  $i. $a+$p[-$a-]$w[@a-$o(-)$w] }

; implements removal of comments. Because of the newline we don't reuse this
{p (,----------)++++++++++.(-) }                    ; purge comments

; auto alighning bracket. ( is the one of two '(' and ')' where ( sets a stack
; to the position it is nowe and print out a  [.
{o; open brackets
    $o((-)
    $t+++++++(-$i+++++++)$i++.(-) ; convert "(" to "[" by adding 51
    $a-$w+[-<+]-@d                ; seek to -1
    $b @r(@d) +                   ; mark
    @d(@r)+[->+]-@a               ; first zero, then first -1

    $p(-$w++[-<+]-@d
        $b @r(@d) $d+
        @d(@r)+[->+]-@a           ; first zero, then first -1
        )
    $a+$w(-$p+)
    )+$i(.(-)$e+)
    open brackets end
}

; auto alighning bracket. ) is the second of two '(' and ')' where ) pops the stack
; and creates the command to move to that location before changing ) to a ]
{c; close bracket
    $o((-)
    $i(-)                we need i
    $w-$t+[-<+]--        move backwards to stack ; -1 set to -2
    <<<[<<]->>           move along stack area until zero; set it to -1
    [-                   pour stack element to a and i
        [>>]+[->+]-@w
        $a+$i+
        +[-<+]->>
    ]
    <<+++[-->++]-        reset stack element mark and restore stack mark; from -2 to -1
    [>]+[->+]@w

    $z<++++++[->++++++++++<]  60 in z ; (<)
    $t+
    error checking is i 0 set e to 2 t is still 1
    $i[-$t-$w+$a-
        we have new position in i and old in p
        $p(- $a [-$w-]<[@w-
        $p+(-$z.) $t] $w+$p)    a is smaller than p; eg. <
        $z++$w-$a(-$z.)$z(-)
        $i(-$p+)                set current position
    $t]>[@t$e+++++$t->]         set error flag if t is not set
    $w+++++++(-$t+++++++++++++)$t++. print close ; eg. "]"
    (-)                         blank out w
    )+$i(.(-)$e+)               set error if e set
    close bracket end
}

; implements the (:). It defines a variable in pretty much the same
; way it defines a macro_area but justs leave it at that. If you redefine
; already existing array you will get ERROR
{s; set variable
    define new variable start
    $i. &i $v.           readprint i and v
    &O                   open path to array index like input

    error checking code for double assignment
    &C                   go to array
    $v((-) &Z $e+ &C)    when v i set then set e
    &Z                   go from array

    $g+(- $t+            copy incremented g
       &C $v+            to t_backup and var location
       &Z )              go back
    &C&R                 close array
    $t(- $g+)            restore g
    define variable end
}

; implements the ($). It creates the brainfuck code to move from the current
; position to that position. Trying to move to a prosition not defined with :
; prints ERROR.
{v; variable position
    $o((-)
    $i.(-)                                  ; print and zero input,

    read print to v &i $v.                      ; read finished
    $t+

    &O                      ; open path to array index like input
    &C                                  ; if zero it is not defined.
    $v(- &B+ &F@v$z @z(@c)          ; copy v to c-1 ...
        $i + $a + &C )                    ; i and a
        &B(-&F+$c@z)&F@v          ; restore original value
        &R                               ; close array
    <++++++(->++++++++++)                   ; 60 in z (<)

    error checking is i 0 set e to 2 t is still 1
    $i[-$t-$w+$a-
    ; we have new position in i and old in p
    $p( $a [-$w-]<[@w-
        $p[-$z.$p] + $t] $w+$p-)            ; a is smaller than p, eg. <
    $z++$w-$a(-$z.)$z(-)
    $i(-$p+)                                ; set current position

    $t]>[@t$e+$t->]@w                       ; set error flag if t is not set
    )+$i((-)$e+)
    variable position end
}

; implements the at (@). After an uneven loop you may use @ to
; indicate where amoungst the variables the  applicatuion is.
; trying to indicate a non existing variable will induce ERROR
; reading this code you see that it is also used to simplify
; some code by using the same variable structure somewhere else
; that it's original location.
{a; set position @
    $i. &i $v.  readprint i and v
    $o(-)+      set overflow
    $e+$p(-)-   set error and p to 255
    &O &C       open and go to array value
    $v(-        copy v
     &B + &F    to backup
     &Z         move from array
      $p + $e(-)and to p and reset e
     &C         move to array
    )           end copy

    restore backup
    &B(-
      &F+$c@z
    )&F

    &R         close array
    set position end
}

; implements the (!). Deletes a variable defined with (:). It HAS to be
; the last variabel created and need to be defined. Failing both these
; criterias will induce ERROR. I have never actually used this, but the
; though was to create variables and delete them at will.
{d;     delete  variable
        $i.(-) &i $v.$e+         readprint i and v and set error
        &O &C                 open path and goto array location
        $v(-                  copy v to
            &Z $t + $e(-)     t and reset e
            &C )
        &R                    close array
        $t(-$i+$g-)           copy to i while reducing both g and t
        $g((-)$e+$i(-))       t is 0 if g is not 0 we have error
        $i(-$g+)$g-           restore g
}

; implements macro definition ({). It has an macro index that gets incremented
; for each one and that is tsored in the macro names index. it is just appended
; to the end where the next macro (or input buffer) should be. It moves the
; input bufer accordingly. It is not allowed to define macroes inside macroes and
; therefor you will never have input in buffer when in this part of the code.
{m; macro open tag
    $v,                 read input into v macro definitions cannot come from macroes
    &O                  open path to array index like input

    error checking code for double assignment
    &C$m((-)            move to variable check if non zero
    &Z $e+ &C)          when non zero set e ; ERROR
    &Z                  back to z

    $G+(- $t+ &C$m+&Z ) increment G and copy g to t and n
    &C&R                clear trail
    $t(- $G+)           restore new G

    |B|F|Z|test|0|0|test2|0|0
    $M>>[[>]>>>]
    >[-]                remove marker
    @t to make this easy we assume we are at t
    $t+$i,(
        $t+++++++(-$i-------)+$i---          reduce by 59;  (;)
        (>+++++++(-<--------)+<              reduce by 64;  ({)
            (--                              reduce by 2 ;  (})
            ( restore by increase of 125
                $t++++++++++(-$i+++++++++++) increase 121
                $i++++>@i                    inc 4 == 125
                $w+
            )$t (-                           in close macro ;eg }
                $i(-)
            )
            )$t(-                            in open macro which
                $i(-)                        is an error since
                -<++[--<++]--@M              a macro definition cannot
                $e+$M>>[[>]>>>]@i            contain another macro definition
            )
        )$t(-                   in comment ignore everything until cr; (;)
            $i+(,----------)    read until cr
            ++++++++++
            >@i
            $w+
        )
        $w(-$t+$i,              continue reading if w is set
            +[-$t-]$w[@t-$w]    check eof
            $t+                 set t for next run
        )
    )>>>>                       set new buffer marker
    +[--<++]--@M                go back to ~2
    end macro open tag
}

; implements macro expansion (&). It will lookup the index value from the macro name
; and move to the end of that macro index and create a mark (-1). It will then copy backwards
; 0|macrocontents|-1|0|0| => 0|-1|macrocontents|0|0|..(other macroes)...-2|previous content|stnetnocorcam|0|-1
; then it will crean up so that we have the same structure only with added content in buffer
; -2|0|macrocontents|0|0|0|..(other macroes)...-1|previous content|stnetnocorcam|0...
{r; replace do macro
    $i.(-)$e+               ; print out i. set error flag
    read print to v &i $v.  ; read finished

    &O                      ; open path to array index like input
    &C                      ; move to array value
    $m(- &B + &F &Z         ; copy n  to c-1 ...
        $Z +  &C            ; Z and reset error flag
    )                       ; end copy
    &B(-$z@c$m+$c@z)&F      ; restore original value
    &R                      ; close array

    $Z($e(-)$Z-(- $I>
        [[>]>>]<<+++[--<++]--@M
        )
    $I >[[>]>>]<<->>>                       ; set first zero to 255
    [[>]>>>]                                ; move to last element
    +>[<-
        >-[>]>-<<[<]                        ; set next byte to input to 255.. we now have M=255|......|0|macrocontents|255|0|0|......|contentstart=254|.....|0|255.
    ]<[-
        >-->>-<<<<
    ]
    +[-<+]-
    <[
        [->>++[->+]-<++[-<+]-<]             ; copy byte to next byte and end of buffer
        >>+[->+]>-<+[-<+]<-<]               ; move 255 to new open space and repeat |0*|0|255|macrocontents|0|nextmacro
    >+>>[ [-<<+>>]>]                        ; copy back to |0*|macrocontents|0|0|0|nextmacro
    <<->+[->+]++[--<++]-<+[-<+]             ; seek back to current array macro_area
    +[-<[<]<<]@Z)
    do macro end
}

; read from buffer. If buffer is empty read from stdin. does not check for EOF
; it seeks to -1, change it to -2. Then moves to the left until a empty cell is
; reached. This is  then marked with -1 and th eprevious cell will be copied back
; to the main variable area using -1 marks. removes the -1 and restores the -2 to -1
; before returning.
{i
        read input to v and output
        $t->+[->+]-->                       set 255 to t then move to first 255 on the right set to 254 move right
        [[>]                                move right until 0 to the right of data

        optimized by dividing input with 8 and moving 8s to v
        then the remainder so that copy takes fewer moves across data
        avg data is 67 so on average we move 7 times to increse 8
        then 3 giving a total of 10 rounds instead of 66
        ++++++++                            set 8 in the cell next to data
        <[->-[>+>>]>[+[-<+>]>+>>]<<<<<]     divids input with 8
        after 0=0 1=positive 2=n%d 3=n/d
        >>>>-<                              mark 255
        [- <+[-<+]-@t$v++++++++$w+[->+]-<]  copy result of div from input to v mul 8
        >+<-<
        [- <+[-<+]-@t$v+$w+[->+]-<]         copy remainder from from input to v
        >+<<[-]<                            cleanup
        ]

        ++[--<++]-<                         move to 254 marker set to 255
        +[-<+]@t                            move to t and reset input is in i
        $m+$v[$m-$m]$z                      check if v is set
        [@m- $v, $z]                        if then we read from stdin

}

; Often used macroes and because of speed moved
; closer to the buffer.

; Open array path. It expects v to contain a ascii and will
; tag the bread crumb until they are at that ascii values
; position.
{O      $v(-$c(@z)+@z(@c))                          open array path
}
; Rerset array. Must be at the forct set bread crumb and will
; remove that flag on it's way to zero.
{R      $z(@c-)                                     reset array
}
; Crumble. Will move crubles until the first 0 is met. This is
; by definition the active array element
{C      $c(@z)                                      move left
}
; Zero. Same as Cruble but reverse. It moves from array
; to variable position
{Z      $z(@c)                                      move right
}
; Back and Forward. Used to backup any value in array to be restored after copy.
{B      $c@z$c }; backward to copy
{F      $z@c$v }; forward from copy

; End macro definitions
; ###########################################################################
; ############################################################################

start stack structure
:r macro return address stack
:b bracket stack
:d stack marker

start array structure
:c array crumble
:v variable value
:m macro
end array structure

:z zero indicates end of array
:g global variable index
:G global macro index

:i input
:t temporary must be next to w and i
:w working must be between t and a
:a adding aide must be next to w
:p position eg the current location
:e error number
:o overflow flag expect at after this
:Z zero

macros area
:M Macro area

input area with bytes written from ne or more macros
:I Input area

>>>++                                               ; 2 stacks of 256 elements
(-<++++(-<++++++++))<<-                             ; multiplied by 32 and then reduced by 1
[->>>>>>>[>>>>>>>>]+[<<<<<<<<]>]                    ; 8*63 = 504+8
>>>>>>>[->>>>>>>>]                                  ; goto 512
<<<->>>                                             ; set -1

>>>+++                                              ; number of variables in array
(-<++++(-<++++++++))<<-                             ; multiplied by 32 and then reduced by 1
[->>>>>>>[>>>>>>>>]+[<<<<<<<<]>]                    ; multiplied by 8 cells = 760 (3 elements)
>>>>>>>[->>>>>>>>]                                  ; goto 768
@z ; indicates that we are on z
$o+$M-->>>-
$v ,(                                               ; outer loop. EOF=0

; copy $i to $w
(- $t+ $w+)                                         ; pour $i to $w and $t
$t(- $i+)                                           ; pour $t to $i
+                                                   ; i=I|t=1|w=I|p=x
; switch
$a +++(- $w -----------)                            ; reduce $w with 3*11=33(!)
 $w (---                                            ; no, reduce $w with 3($)
     (--                                            ; no, reduce $w with 2 (&)
      (--                                           ; no  reduce $w with 2 "("
       (-                                           ; no  reduce $w with 1 ")"
        ( $a++++(- $w---- ) $w-                     ; no, reduce $w with 17(:)
         ( -                                        ; no, reduce by 1 (;)
          ( -                                       ; no, reuce by 1 (<)
           ( --                                     ; no, reuce by 2 (>)
            ( --                                    ; no, reduce by 2 (@)
             ( $a+++++++(- $w--------) $w---        ; no, reduce by 59 ({)
              ((-) $i . $t- )                       ; reset $t and $w
             $t (- macro &m  ))                     ; in {
            $t (- at &a      ))                     ; in @
           $t (- greater &g  ))                     ; in > adjusts pos
          $t (- lessthan &l  ))                     ; in < adjusts pos. Make sure we don't go below 0.
         $t (  purge &p      ))                     ; in ; removes comment
        $t (- set &s         ))                     ; in :
       $t (- close &c        ))                     ; in ")"
      $t (- open &o          ))                     ; in "("
     $t (- replace &r        ))                     ; in &
    $t (- varmove &v         ))                     ; move to a ($) (t is 1)
   $t (- delete &d           )                      ; !

check for error
$i(-)                                               ; reset i
$t+                                                 ; set flag
$e(
    $e(-)$t-$c<+>->(-)>(-)                          ; remove flag. simulate stack at v.
)
$t(-                                                ; if flag set (no error)
read another byte and exit if EOF
&i
$m+$v+   check for ~1
[-$m-]   at eof if in this
$z[@m->] ))                                      ; loop until read EOF == 0/ -1/ no change

&e
