;[
; $Id$
; an extended brainfuck to pure brainfuck compiler
; for documentation, please go to http://sylwester.no/ebf/
;
; ebf-compiler is free software: you can redistribute it and/or modify
; it under the terms of the GNU General Public License as published by
; the Free Software Foundation, either version 3 of the License, or
; (at your option) any later version.
;
; ebf-compiler is distributed in the hope that it will be useful,
; but WITHOUT ANY WARRANTY; without even the implied warranty of
; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
; GNU General Public License for more details.
;
; You should have received a copy of the GNU General Public License
; ]

ML|crumble|variable|macro|zero|global|global_macro|input|tmp|working|adding|position|error|nooverflow|macro_number|flag|zero|macro_area|input_area|tmp|wrk
PTR=1277|3

; #########################################################################################
; MACRO DEFINITIONS

{g  $i.$a+$p+++[$a-]$w[@a-$o(-)$p-$w]$p-- }         ; greater than

{l  $i. $a+$p[-$a-]$w[@a-$o(-)$w] }                 ; less than

{p (,----------)++++++++++.(-) }                    ; purge comments

{e;              error if stack set
                ; need to check stack for uneven brackets
                $z+[-<+]<
                    [
                    >>+++++++++[->++++++++<]>---                    ; prints ERROR using previous block
                    .+++++++++++++..---.+++.                        ; and both previous and cuurent block is zero after
                    (-)++++++++++.(-)
                ]
}

{m;              macro open tag
                $v,                                 ; read input into v. macro definitions cannot come from macroes
                &O                  ; open path to array index like input

                error checking code for double assignment
                &C$m((-)                      ; move to n(i) check if non zero
                &Z $e+ &C)                ; when non zero go to e and set 1 (: error)
                &Z                              ; back to z

                $G+(- $t+ &C$m+&Z )       ; increment G and copy g to t and n
                &C&R                       ; clear trail
                $t(- $G+)                           ; restore new G

                |B|F|Z|test|0|0|test2|0|0
                $M>>[[>]>>>]
                >[-]                                ; remove marker
                @t to make this easy we assume we are at t
                $t+$i,(
                    $t+++++++(-$i-------)+$i---     ; reduce by 59 (;)
                    (>+++++++(-<--------)+<         ; reduce by 64 ({)
                      (--                           ; reduce by 2 (})
                        ( increase by 125
                            $t++++++++++(-$i+++++++++++); increase by 121
                            $i++++>@i                   ; 4 == 125
                            $w+
                        )$t (-                        ; in }
                          $i(-)
                        )
                      )$t(-
                          $i(-)
                          -<++[--<++]--@M
                          $e+$M>>[[>]>>>]@i
                        )
                    )$t(-                           ; in ; ignore everything until cr
                        $i+(,----------)            ; read until cr
                        ++++++++++
                        >@i
                        $w+
                    )
                    $w(-$t+$i,
                        +[-$t-]$w[@t-$w]
                        $t+
                    )
                    $i
                )
                ++[--<++]--@M
                end macro open tag
}

{a; set position
    $i. &i $v.  readprint i and v
    $o(-)+      set overflow
    $e+$p(-)-   set error and p to 255
    &O &C       open and go to array value
    $v(-        copy v
     &B + &F    to backup
     &Z         move from array
      $p + $e(-)and to p and reset e
     &C         move to array
    )           end copy

    restore backup
    &B(-
      &F+$c@z
    )&F

    &R         close array
    set position end
}

{s; set variable
    define new variable start
    $i. &i $v.           readprint i and v
    &O                   open path to array index like input

    error checking code for double assignment
    &C                   go to array
    $v((-) &Z $e+ &C)    when v i set then set e
    &Z                   go from array

    $g+(- $t+            copy incremented g
       &C $v+            to t_backup and var location
       &Z )              go back
    &C&R                 close array
    $t(- $g+)            restore g
    define variable end
}

{c;         close bracket
           $o((-)
           $i(-)                                    ; we need i
           $w-$t+[-<+]--
           <<<[<<]->>
           [-
             [>>]+[->+]-@w
             $a+$i+
             +[-<+]->>
           ]
           <<+++[-->++]-                            ; restore mark from -2 to -1
           [>]+[->+]@w

           $z<++++++[->++++++++++<]                  ; 60 in z (<)
           $t+
            error checking is i 0 set e to 2 t is still 1
            $i[-$t-$w+$a-
            ; we have new position in i and old in p
            $p(- $a [-$w-]<[@w-
            $p+(-$z.) $t] $w+$p)                    ; a is smaller than p, eg. <
            $z++$w-$a(-$z.)$z(-)
            $i(-$p+)                                ; set current position
            $t]>[@t$e+++++$t->]                     ; set error flag if t is not set
            $w+++++++(-$t+++++++++++++)$t++.        ; print "]"
            (-)                                     ; blank out w
            )+$i(.(-)$e+)
            close bracket end
}

{o;          open brackets
            $o((-)
            $t+++++++(-$i+++++++)$i++.(-)           ; convert "(" to "[" by adding 51
            $a-$w+[-<+]-@d                          ; seek to -1
            $b @r(@d) +                             ; mark
            @d(@r)+[->+]-@a                         ; first zero, then first -1

            $p(-$w++[-<+]-@d
                $b @r(@d) $d+
                @d(@r)+[->+]-@a                     ; first zero, then first -1
              )
            $a+$w(-$p+)
            )+$i(.(-)$e+)
            open brackets end
}

{r;          replace do macro
            $i.(-)$e+                               ; print out i. set error flag
            read print to v &i $v.                  ; read finished

            &O                      ; open path to array index like input
            &C                                  ; move to array value
            $m(- &B + &F &Z             ; copy n  to c-1 ...
                $Z +  &C                        ; Z and reset error flag
            )                                       ; end copy
            &B(-$z@c$m+$c@z)&F              ; restore original value
            &R                                 ; close array

            $B(-)+                  report bytes
            $Z($e(-)$Z-(- $I>
                [[>]>>]<<+++[--<++]--@M
              )
            $I >[[>]>>]<<->>>                       ; set first zero to 255
            [[>]>>>]                                ; move to last element
            +>[<-
                >-[>]>-<<[<]                        ; set next byte to input to 255.. we now have M=255|......|0|macrocontents|255|0|0|......|contentstart=254|.....|0|255.
            ]<[-
                >-->>-<<<<
            ]
            +[-<+]-
            <[
                [->>++[->+]-<++[-<+]-<]             ; copy byte to next byte and end of buffer
                >>+[->+]>-<+[-<+]<-<]               ; move 255 to new open space and repeat |0*|0|255|macrocontents|0|nextmacro
            >+>>[ [-<<+>>]>]                        ; copy back to |0*|macrocontents|0|0|0|nextmacro
            <<->+[->+]++[--<++]-<+[-<+]             ; seek back to cuuent array macro_area
            +[-<[<]<<]@Z)
            do macro end
}

{v;          variable position
            $o((-)
            $i.(-)                                  ; print and zero input,

            read print to v &i $v.                      ; read finished
            $t+

            &O                      ; open path to array index like input
            &C                                  ; if zero it is not defined.
            $v(- &B+ &F@v$z @z(@c)          ; copy v to c-1 ...
              $i + $a + &C )                    ; i and a
              &B(-&F+$c@z)&F@v          ; restore original value
              &R                               ; close array
            <++++++(->++++++++++)                   ; 60 in z (<)

            error checking is i 0 set e to 2 t is still 1
            $i[-$t-$w+$a-
            ; we have new position in i and old in p
            $p( $a [-$w-]<[@w-
                $p[-$z.$p] + $t] $w+$p-)            ; a is smaller than p, eg. <
            $z++$w-$a(-$z.)$z(-)
            $i(-$p+)                                ; set current position

            $t]>[@t$e+$t->]@w                       ; set error flag if t is not set
            )+$i((-)$e+)
            variable position end
}

{d;     delete  variable
        $i.(-) &i $v.$e+         readprint i and v and set error
        &O &C                 open path and goto array location
        $v(-                  copy v to
            &Z $t + $e(-)     t and reset e
            &C )
        &R                    close array
        $t(-$i+$g-)           copy to i while reducing both g and t
        $g((-)$e+$i(-))       t is 0 if g is not 0 we have error
        $i(-$g+)$g-           restore g
}

{i
        read input to v and output
        $B(-                                if we think it's bytes in buffer
        $t->+[->+]-->                       set 255 to t then move to first 255 on the right set to 254 move right
        [[>]- <                             move right until 0 to the right of data set to 255
        [- <+[-<+]-@t$v+$w+[->+]-<]         copy from oldest data position to v
        >[+]]                               move to 255 and reset
        ++[--<++]-<                         move to 254 marker set to 255
        +[-<+]@t                            move to t and reset input is in i
        )                                   reset F
        $m+$v[$m-$B+$m]$z                   set B again if its ok
        [@m- $v, $z]                        buffer empty need to read from input

}

{O      $v(-$c(@z)+@z(@c))                          open array path
}
{R      $z(@c-)                                     reset array
}
{C      $c(@z)                                      move left
}
{Z      $z(@c)                                      move right
}
{B      $c@z$c }; backward to copy
{F      $z@c$v }; forward from copy

; End macro definitions
; ###########################################################################
; ############################################################################

start stack structure
:r macro return address stack
:b bracket stack
:d stack marker

start array structure
:c array crumble
:v variable value
:m macro
end array structure

:z zero indicates end of array
:g global variable index
:G global macro index
:i input
:t temporary must be next to w and i
:w working must be between t and a
:a adding aide must be next to w
:p position eg the current location
:e error number
:o overflow flag expect at after this
:B n bytes written from macro
:F flag
:Z zero

macros area
:M Macro area

input area with bytes written from ne or more macros
:I Input area

>>>++                                               ; 2 stacks of 256 elements
(-<++++(-<++++++++))<<-                             ; multiplied by 32 and then reduced by 1
[->>>>>>>[>>>>>>>>]+[<<<<<<<<]>]                    ; 8*63 = 504+8
>>>>>>>[->>>>>>>>]                                  ; goto 512
<<<->>>                                             ; set -1

>>>+++                                              ; number of variables in array
(-<++++(-<++++++++))<<-                             ; multiplied by 32 and then reduced by 1
[->>>>>>>[>>>>>>>>]+[<<<<<<<<]>]                    ; multiplied by 8 cells = 760 (3 elements)
>>>>>>>[->>>>>>>>]                                  ; goto 768
@z ; indicates that we are on m
$o+$M--
$v ,(                                               ; outer loop. EOF=0

; copy $i to $w
(- $t+ $w+)                                         ; pour $i to $w and $t
$t(- $i+)                                           ; pour $t to $i
+                                                   ; i=I|t=1|w=I|p=x
; switch
$a +++(- $w -----------)                            ; reduce $w with 3*11=33(!)
 $w (---                                            ; no, reduce $w with 3($)
     (--                                            ; no, reduce $w with 2 (&)
      (--                                           ; no  reduce $w with 2 "("
       (-                                           ; no  reduce $w with 1 ")"
        ( $a++++(- $w---- ) $w-                     ; no, reduce $w with 17(:)
         ( -                                        ; no, reduce by 1 (;)
          ( -                                       ; no, reuce by 1 (<)
           ( --                                     ; no, reuce by 2 (>)
            ( --                                    ; no, reduce by 2 (@)
             ( $a+++++++(- $w--------) $w---        ; no, reduce by 59 ({)
              ((-) $i . $t- )                       ; reset $t and $w
             $t (- macro &m  ))                     ; in {
            $t (- at &a      ))                     ; in @
           $t (- greater &g  ))                     ; in > adjusts pos
          $t (- lessthan &l  ))                     ; in < adjusts pos. Make sure we don't go below 0.
         $t (  purge &p      ))                     ; in ; removes comment
        $t (- set &s         ))                     ; in :
       $t (- close &c        ))                     ; in ")"
      $t (- open &o          ))                     ; in "("
     $t (- replace &r        ))                     ; in &
    $t (- varmove &v         ))                     ; move to a ($) (t is 1)
   $t (- delete &d           )                      ; !

check for error
$i(-)                                               ; reset i
$t+                                                 ; set flag
$e(
    $e(-)$t-$c<+>->(-)>(-)                     ; remove flag. simulate stack at v.
)
$t(-                                                ; if flag set (no error)
read another byte and exit if EOF
&i
$m+$v+   check for ~1
[-$m-]   at eof if in this
$z[@m->] ))                                      ; loop until read EOF == 0/ -1/ no change

&e