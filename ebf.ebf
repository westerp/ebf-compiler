;[
; $Id$
; an extended brainfuck to pure brainfuck compiler
; for documentation, please go to http://sylwester.no/ebf/
;
; ebf-compiler is free software: you can redistribute it and/or modify
; it under the terms of the GNU General Public License as published by
; the Free Software Foundation, either version 3 of the License, or
; (at your option) any later version.
;
; ebf-compiler is distributed in the hope that it will be useful,
; but WITHOUT ANY WARRANTY; without even the implied warranty of
; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
; GNU General Public License for more details.
;
; You should have received a copy of the GNU General Public License
; ]

ML|crumble|variable|macro|zero|global|global_macro|input|tmp|working|adding|position|error|nooverflow|macro_number|flag|zero|macro_area|I|buf|fun|inp|sub|more|test|error|hash|copy|source|htmp|33|
PTR=1285|3

; #########################################################################################
; MACRO DEFINITIONS

; stack_error prints out ERROR if stack set
; It is used in the end of the application
{print_if_stack_error
    ++[--<++]@M
    +[-<+]<
    [                                   ; need to check stack for uneven brackets
        >>+++++++++[->++++++++<]>---    ; prints ERROR using previous block
        .+++++++++++++..---.+++.        ; and both previous and cuurent block is zero after
        (-)++++++++++.(-)
    ]
}

; macro for implementing the > which increases the pointer or
; resets overflow. for normal operation overflow is always set
{go_up &buf2var $a+$p+++[$a-]$w[@a-$o(-)$p-$w]$p-- &fake_buffer}

; macro for implementing the < which decreases the pointer or
; resets overflow. for normal operation overflow is always set
{go_down &buf2var $a+$p[-$a-]$w[@a-$o(-)$w] &fake_buffer}

; implements removal of comments. Because of the newline we don't reuse this
{rm_comment $inp(,----------)++++++++++.(-) }                    ; purge comments

; auto alighning bracket. ( is the one of two '(' and ')' where ( sets a stack
; to the position it is nowe and print out a Â [.
{open
    &buf2var
    $i+                           ; set i
    $o((-)
    $t++++++++++(-$i+++++++++)$i.(-) ; create a "[", print and delete
    $a-$w+[-<+]-@d                ; seek to -1
    $b @r(@d) +                   ; mark
    @d(@r)+[->+]-@a               ; first zero, then first -1

    $p(-$w++[-<+]-@d
        $b @r(@d) $d+
        @d(@r)+[->+]-@a           ; first zero, then first -1
        )
    $a+$w(-$p+)
    )+$i(
      $t++++++(-$i+++++++)$i---.(-); create a "("
      $e+)
    &fake_buffer
    open brackets end
}

{macstart
  push position on stack
    &buf2var
    $a-$w+[-<+]-@d                ; seek to -1
    $r @r(@d) +                   ; mark
    @d(@r)+[->+]-@a               ; first zero, then first -1

    $p(-$w++[-<+]-@d
        $r @r(@d) $d+
        @d(@r)+[->+]-@a           ; first zero, then first -1
        )
    $a+$w(-$p+)
    &fake_buffer
    macstart end
}

{macrend
  remove position on stack
    $I[<]<+[-<+]-@d                 ; seek to -1
    $r @r(@d) $d(-)                 ; delete
    @r$d(@r)+[->+]-[>]@buf          ; move back
  macrend end
}

{param
  move to position in stack
  with possible numeric operand for offset indication
#
  $buf+$I+[-$buf-@function]>[-@buf$I-$buf$inp]
  $buf(-$function+$inp+)
  
  $tmp++++++(-$inp--------) ; reduce test by 48 ascii 0
  $wrk+++++++++
  (<<[->]>[<]@tmp$wrk-)
  $tmp+
  $inp((-) $tmp- $function(-$buf+))
  $tmp($function.$tmp+++++(-$function--------))

  $function(  ;-+ cancelled
              +[--<++]--@M
              $z+
              +[->+]-[>]@buf )

  &buf2var
  $w-$t+[-<+]--@d                 ; seek to -1 set to -2
  $r( (@d) -                      ; delete set -1
  $d                              ; tmp|-1|x....
  [ [->+]-@w                      ; reduce
    $a+$i+
    +[-<+]-
    <<+>>>> ]
  <<+<<@r(->>>>+)                 ; restore stack
  >>>>[>>]@r)<<+>                 ; retore marker from -2 to -1
  +[->+]@w$t+                     ; move back and increase t
  $i[ $z(-$i+$a+) $t-]
  $w(@t-)$t+
  &posmove
  &fake_buffer
}



; multiply the next operation by parameter count
; only supports cell size increase
{multiply
  TODO reimplement in buffer
  &buf2var
  $t+(-
    &I    ; read input into v
    $v.(-$m+$z+$i+)               copy to m z and i
    $v++++++++(-$m------$z------) reduce by 48
    $c+++++++++                   ser 9 in c
    (>>[-<]<[>]@v$c-)             m sub c
    $v+
    $m (   m was not number
        $z(-)
        check for lt and gt and update postion and reset nooverflow if overflow
        $m---(
        --( (-) $v- $w(-(-$i.)) )
          $v (- $p+++ $w(-(>>[+<]<[>]@a$i.$w-)) $a+$p[--<-]$w(-@a$o(-)) )       ; >
        ) $v (- $w(-(>>[-<]<[>]@a$i.$w-)) $a+$p[-<-]$w(-@a$o(-)) )              ; <
        $t- set t to ~1
      )
    $v(-          m was number
        $w(-$a++++++++++)$a(-$w+)
        $z(-$w+)
      )
    $i(-)
    $t+
  )
  &fake_buffer
}

; print_string takes a string parameter double quotes
; expects that the current cell and next cell are empty 
{print_string
  please implement print_string
}

{store_string
  please implement store_string
}

; auto alighning bracket. ) is the second of two '(' and ')' where ) pops the stack
; and creates the command to move to that location before changing ) to a ]
{close
    &buf2var
    $i+$o((-)
    $i(-)                we need i
    $w-$t+[-<+]--        move backwards to stack ; -1 set to -2
    <<<[<<]->>           move along stack area until zero; set it to -1
    [-                   pour stack element to a and i
        [>>]+[->+]-@w
        $a+$i+
        +[-<+]->>
    ]
    <<+++[-->++]-        reset stack element mark and restore stack mark; from -2 to -1
    [>]+[->+]@w

    $z<++++++[->++++++++++<]  60 in z ; (<)
    $t+
    error checking is i 0 set e to 2 t is still 1
    $i[-$t-$w+$a-
        we have new position in i and old in p
        $p(- $a [-$w-]<[@w-
        $p+(-$z.) $t] $w+$p)    a is smaller than p; eg. <
        $z++$w-$a(-$z.)$z(-)
        $i(-$p+)                set current position
    $t]>[@t$e+++++$t->]         set error flag if t is not set
    $w+++++++(-$t+++++++++++++)$t++. print close ; eg. "]"
    (-)                         blank out w
    )+$i(
         $t++++++(-$i+++++++)$i--.(-)
         $e+
        )               set error if i set
    &fake_buffer
    close bracket end
}

; implements the (:). It defines a variable in pretty much the same
; way it defines a macro_area but justs leave it at that. If you redefine
; already existing array you will get ERROR
{var_create
    define new variable start
    &array_open                   open path to array index like input

    error checking code for double assignment
    &array_element                   go to array
    $v((-) &array_back $e+ &array_element)    when v i set then set e
    &array_back                   go from array

    $g+(- $t+            copy incremented g
       &array_element $v+            to t_backup and var location
       &array_back )              go back
    &array_element&array_close                 close array
    $t(- $g+)            restore g
    define variable end
}

; implements the ($). It creates the brainfuck code to move from the current
; position to that position. Trying to move to a prosition not defined with :
; prints ERROR.
{var_move
    $e+                                         ; set error
    $o((-)
    $e(-)                                       ; zero input,
    $t+

    &array_open                      ; open path to array index like input
    &array_element                                  ; if zero it is not defined.
    $v(- &B+ &F@v$z @z(@c)          ; copy v to c-1 ...
        $i + $a + &array_element )                    ; i and a
        &B(-&F+$c@z)&F@v          ; restore original value
        &array_close                               ; close array
      &posmove
    )+
    variable position end
}


; Assumes we have a position in i and a
; where we want to move and create < and >
; to do so. Used by both varmove and param 
{posmove
    $z<++++++(->++++++++++)                   ; 60 in z (<)

    error checking is i 0 set e t is still 1
    $i[-$t-$w+$a-
    ; we have new position in i and old in p
    $p( $a [-$w-]<[@w-
        $p[-$z.$p] + $t] $w+$p-)            ; a is smaller than p, eg. <
    $z++$w-$a(-$z.)$z(-)
    $i(-$p+)                                ; set current position

    $t]>[@t$e+$t->]@w                       ; set error flag if t is not set
}


; implements the at (@). After an uneven loop you may use @ to
; indicate where amoungst the variables the  applicatuion is.
; trying to indicate a non existing variable will induce ERROR
; reading this code you see that it is also used to simplify
; some code by using the same variable structure somewhere else
; than it's original location.
{var_position_set
    $o(-)+      set overflow
    $e+$p(-)-   set error and p to 255
    &array_open &array_element       open and go to array value
    $v(-        copy v
     &B + &F    to backup
     &array_back         move from array
      $p + $e(-)and to p and reset e
     &array_element         move to array
    )           end copy

    restore backup
    &B(-
      &F+$c@z
    )&F

    &array_close         close array
    set position end
}

; implements the (!). Deletes a variable defined with (:). It HAS to be
; the last variabel created and need to be defined. Failing both these
; criterias will induce ERROR. I have never actually used this, but the
; though was to create variables and delete them at will.
{var_del                   delete  variable
        $e+                   set error
        &array_open &array_element                 open path and goto array location
        $v(-                  copy v to
            &array_back $t + $e(-)     t and reset e
            &array_element )
        &array_close                    close array
        $t(-$i+$g-)           copy to i while reducing both g and t
        $g((-)$e+$i(-))       t is 0 if g is not 0 we have error
        $i(-$g+)$g-           restore g
}

; implements macro definition ({). It has an macro index that gets incremented
; for each one and that is stored in the macro names index. it is just appended
; to the end where the next macro (or input buffer) should be. It moves the
; input bufer accordingly. It is not allowed to define macroes inside macroes and
; therefor you will never have input in buffer when in this part of the code.
{macro_create
    &array_open                  open path to array index like input

    error checking code for double assignment
    &array_element                            move to variable
    $m((-) &array_back $e+ &array_element )   when non zero set e ; ERROR

    &array_back                              back to z
    $G+(- $t+ &array_element $m+ &array_back ) increment G and copy g to t and m
    &array_element &array_close               clear trail

    $t(- $G+)           restore new G

    there is always a ~1 where input starts and its to the right of where macro should have its first char
    lets copy buf there
    +[->+]@I      move to I and remove marker
    $buf(-$M+)$I  copy first buffer 
;    |B|F|Z|test|0|0|test2|0|0|0|~1
;    $M>>[[>]>>>]
;    >(-)                remove marker
    @t to make this easy we assume we are at t
;    $t+$i[$t-]>(@t-$i,)
    $t+$i(
        $t+++++++(-$i-------)+$i---          reduce by 59;  (;)
        (>+++++++(-<--------)+<              reduce by 64;  ({)
            (--                              reduce by 2 ;  (})
            ( restore by increase of 125
                $t++++++++++(-$i+++++++++++) increase 121
                $i++++>@i                    inc 4 == 125
                $w+
            )$t (-                           in close macro ;eg }
                $t+
;                h=char|i=0|t=1|w=0
                $i<[>]
                >(-)
                >(@i no char in macro error
                  [--<++]--@M                 go back to ~2 while setting i to ~1
                  $e++[->+]@t                 set e and go back to i and say its t
                )
            )
            )$t(                              in open macro which is an error since
                +[--<++]--@M                  a macro definition cannot
                $e+++$M>>[[>]>>>]@i           contain another macro definition
            )
        )$t(-                   in comment ignore everything until cr; (;)
            #$i+<----------
            [++++++++++>-]
            >[-@t]
            $i+(,----------)    read until cr ; TODO: Check for eof-s
            ++++++++++
            >@i
            $w+
        )
        $w(-$t+$i,              continue reading if w is set
            +[-$t-]$w[@t-$w]    check eof
            $t+                 set t for next run
        )
    )>>>>                        set new buffer marker
    +[--<++]--@M                go back to ~2
    end macro open tag
}

; implements macro expansion (&). It will lookup the index value from the macro name
; and move to the end of that macro index and create a mark (-1). It will then copy backwards
; 0|macrocontents|-1|0|0| => 0|-1|macrocontents|0|0|..(other macroes)...-2|previous content|stnetnocorcam|0|-1
; then it will clean up so that we have the same structure only with added content in buffer
; -2|0|macrocontents|0|0|0|..(other macroes)...-1|previous content|stnetnocorcam|0...
{run_macro
    $e+

    &array_open                 ; open path to array index like input
    &array_element              ; move to array value
    $m(- &B + &F &array_back    ; copy n  to c-1 ...
        $Z +  &array_element    ; Z and reset error flag
    )                           ; end copy
    &B(-$z@c$m+$c@z)&F          ; restore original value
    &array_close                ; close array

    $Z($e(-)$Z-(- $I>
        [[>]>>]<<+++[--<++]--@M
        )
    $I >[[>]>>]<<->>>                       ; set first zero to 255
    [[>]>>>]                                ; move to last element
    +>[<-
        >-[>]++>>-<<[<]                     ; set next byte to input to 255.. we now have M=255|......|0|macrocontents|255|0|0|......|contentstart=254|.....|0|255.
    ]<[-
        >-->>-<<<<  ; redundant?
    ]
    +[-<+]-
    <[
        [->>++[->+]-<++[-<+]-<]             ; copy byte to next byte and end of buffer
        >>+[->+]>-<+[-<+]<-<]               ; move 255 to new open space and repeat |0*|0|255|macrocontents|0|nextmacro
    >+>>[ [-<<+>>]>]                        ; copy back to |0*|macrocontents|0|0|0|nextmacro
    <<->+[->+]++[--<++]-<+[-<+]             ; seek back to current array macro_area
    +[-<[<]<<]@Z)

    +[->+]-        goto start of input
    [>]+           set it to 1 eg start of macro
    ++[--<++]--@M  go back to M
    do macro end
}

; read from left char or use read buffer function
{i is depricated &I }

; read from buffer. If buffer is empty read from stdin. does not check for EOF
; it seeks to -1, change it to -2. Then moves to the left until a empty cell is
; reached. This is  then marked with -1 and th eprevious cell will be copied back
; to the main variable area using -1 marks. removes the -1 and restores the -2 to -1
; before returning.
{I  depricated please reimplement in buffer area
        read input to v and output
        $t->+[->+]-->                       set 255 to t then move to first 255 on the right set to 254 move right
        [[>]                                move right until 0 to the right of data

;        optimized by dividing input with 8 and moving 8s to v
;        then the remainder so that copy takes fewer moves across data
;        avg data is 67 so on average we move 7 times to increse 8
;        then 3 giving a total of 10 rounds instead of 66
        ++++++++                            set 8 in the cell next to data
        <&divmod                            divids input with 8
        after 0=0 1=positive 2=n%d 3=n/d
        >>>>-<                              mark 255
        [- <+[-<+]-@t$v++++++++$w+[->+]-<]  copy result of div from input to v mul 8
        >+<-<
        [- <+[-<+]-@t$v+$w+[->+]-<]         copy remainder from from input to v
        >+<<[-]<                            cleanup
        ]

        ++[--<++]-<                         move to 254 marker set to 255
        +[-<+]@t                            move to t and reset input is in i
        $m+$v[$m-]$z                        check if v is set
        [@m- $v, $z]                        if then we read from stdin

        $m+$v+[-$m-]$z                      convert ~1 to 0
        [@m-$z]
}


; Often used macroes and because of speed moved
; closer to the buffer.

; Open array path. It expects v to contain a ascii and will
; tag the bread crumb until they are at that ascii values
; position.
{array_open      $v(-$c(@z)+@z(@c))                          open array path
}
; Rerset array. Must be at the furthest set bread crumb and will
; remove that flag on it's way to zero.
{array_close     $z(@c-)                                     reset array
}
; Crumble. Will move crubles until the first 0 is met. This is
; by definition the active array element
{array_element   $c(@z)                                      move left
}
; Zero. Same as Cruble but reverse. It moves from array
; to variable position
{array_back      $z(@c)                                      move right
}
; Back and Forward. Used to backup any value in array to be restored after copy.
{B      $c@z$c }; backward to copy
{F      $z@c$v }; forward from copy

; this does the divmod. compiler is fuzzy after so caller must fix position to calling
{divmod[->-[>+>>]>[+[-<+>]>+>>]<<<<<]}

{err_move2buf
  copy error flag to error
  $e[ +[->+]-[>]@buf $error+ $I[<]]
  +[->+]-[>]@buf 
}

; functions without parameters that work on variables need this in beginning of function
{buf2var ++[--<++]--@M}

; functions without parameters that work on variables need this in end of function
{fake_buffer
  $a+ @add
}

; End macro definitions
; ###########################################################################
; ############################################################################

start stack structure
:r macro return address stack
:b bracket stack
:d stack marker

start array structure
:c array crumble
:v variable value
:m macro
end array structure

:z zero indicates end of array

:g global variable index
:G global macro index

:i input
:t temporary must be next to w and i
:w working must be between t and a
:a adding aide must be next to w
:p position eg the current location
:e error number
:o overflow flag expect at after this
:Z zero

macros area
:M Macro area ; -2

input area with bytes written from one or more macros
:I Input area ; -1
:buf
:function indicate function with argument to run
:inp input/buffer
:tmp temporary must be next to w and i
:wrk working must be between t and a
:add adding aide must be next to w
:error

>>>++                                               ; 2 stacks of 256 elements
(-<++++(-<++++++++))<<-                             ; multiplied by 32 and then reduced by 1
[->>>>>>>[>>>>>>>>]+[<<<<<<<<]>]                    ; 8*63 = 504+8
>>>>>>>[->>>>>>>>]                                  ; goto 512
<<<->>>                                             ; set -1

>>>+++                                              ; number of variables in array
(-<++++(-<++++++++))<<                              ; multiplied by 32
[->>>>>>>[>>>>>>>>]+[<<<<<<<<]>]                    ; multiplied by 8 cells = 760 (3 elements)
>>>>>>>[->>>>>>>>]                                      ; goto 776
@z ; indicates that we are on z

$o+$M-->>>@I+
$buf,+[-<-]<[-@I<]                                      ; takes care of EOF=-1 on first char
$I-$buf(                                                ; outer loop.

(- $inp+ $wrk+)                                         ; pour $i to $w and $t
$tmp+                                                       ; i=I|t=1|w=I|p=x
; switch

$wrk-                                                   ; reduce $w by 1 (start of macro expanded)
  (-                                                    ; no, reduce by 1 (end of macro expanded)
   (-$add+++(- $wrk ----------)$wrk                     ; reduce $w with -1-3*10=33(!)
    (---                                                ; no, reduce $w with 3($)
     (--                                                ; no, reduce $w with 2 (&)
      (--                                               ; no  reduce $w with 2 "("
       (-                                               ; no  reduce $w with 1 ")"
        (-                                              ; no, reduce $w with 1 "*"
         ( $add++++(- $wrk---- ) $wrk                   ; no, reduce $w with 16(:)
          ( -                                           ; no, reduce by 1 (;)
           ( -                                          ; no, reuce by 1 (<)
            ( --                                        ; no, reuce by 2 (>)
             ( --                                       ; no, reduce by 2 (@)
              ( $add+++(- $wrk----------) $wrk          ; no, reduce by 30 (^)
               ( $add+++(- $wrk----------) $wrk+        ; no, reduce by 29 ({)
                (-                                      ; no, reduce by 1 (|)
                 (  (-) $inp .(-)  $tmp- )                ; reset $wrk and $tmp
                 $tmp (- $inp.(-) &print_string   )     ; in |. create code that prints string
                )$tmp (- macro $inp+++$function+  )     ; in {, output ~, set 1 in i
               ) $tmp (- $inp.(-)  &param         )     ; in ^, move to call position
              )  $tmp (- at      $function+++     )     ; in @, outpuy @, set 2 in i
             )   $tmp (- $inp.(-)      &go_up     )     ; run go_right since > adjusts pos
            )    $tmp (- $inp.(-)      &go_down   )     ; run go_left since < adjusts pos
           )     $tmp (-           &rm_comment    )     ; in ; removes comment
          )      $tmp (- set       $function++    )     ; in :
         )       $tmp (- $inp.(-) &multiply       )     ; in *
        )        $tmp (- $inp(-) &close           )     ; in ")"
       )         $tmp (- $inp(-) &open            )     ; in "("
      )          $tmp (- replace $function++++    )     ; in &
     )           $tmp (- varmove $function+++++   )     ; move to a ($) (t is 1)
    )            $tmp (- delete  $function++++++  )     ; !
   )             $tmp (- $inp-- &macrend          )     ; end of macro
  )              $tmp (- $inp-  &macstart         )     ; macro start

; if add is set we are really in var and need to move
; pointer to var area and copy error 
$add(-@a
  &err_move2buf
)

$function(  if function is set
$inp.(-) print and reset inp
!error!add!wrk!tmp remove allcation except function
buf function hash inp
; inp == c
:sub ; v
:more ; m
:test	; z
:error ; e
:hash
 $more+(-
    ; This either shifts everything (function and hash so far one left or read a byte
    $buf+$I+[  -$buf- $function[-<+>] $error[-<+>] $hash[-<+>]< @hash $inp ]>[-# @buf$I+$buf,[+[-$I-]]<[-@I<] $I- $sub] ; also checks for eof
    $buf(-$inp+$test+)          ; zerocopy v to inp and test
    $more++++++(-$test--------) ; reduce test by 48 ascii 0
    $sub+++++++++               ; set 9 to v
    (>>[-<]<[>]@more$sub-)     ; test - sub
     $more+$test(                ; set more goto test check set
     ;this means it is set eg no match for digits
     --------                   ; reduce z by 8 A
     $more++++(-$sub+++++)$sub     ; set 25 to sub
     (>>[-<]<[>]@more$sub-)    ; z sub v
     $more+$test(
      ;this means it is set eg no match again for upper case letters
      -----                     ; reduce z by 5 _
      (--                       ; check for underscore reduce by 2 ascii a
      $more++++(-$sub+++++)$sub ; set 25 to v
      (>>[-<]<[>]@more$sub-)   ; z sub v
      $more+$test(
      ; this means it is set eg no match against lower case letters
      $more-                       ; reset m
      $test(-)                     ; reset z
  ))))

  $more(-
      :copy:source:htmp:mcon
      $error(-)
      $mcon+++++++++++
      $hash(-$copy+$source+) move h to w
      $mcon(-$copy(- $error+$hash[-<-]<[@error+++++(-$test++++++(-$hash+++++++))$hash--$test] test )$source(-$htmp+$copy+)$htmp(-$source+))
      $source(-$copy-)
      $inp. (- $error+$hash[-<-]<[@error+++++(-$test++++++(-$hash+++++++))$hash--$test] test ) pour c to h
      $error+ set e
      $test+
      !mcon!htmp!source!copy
    )
    $test(-$more+)
  )
; compatibility notice: if first char did not match matched /\w|_/i we have e set to zero
; this will be an error

;!error!test!more!sub
;:divisor:ok:error:ok_error
$more+
$error(-$more-$sub+) we have two flags ok and error
$sub(-

move new char to buffer
$inp(-$buf+)

; print out hash on allocation and macro create only
$function(-$inp+$sub+)
$inp(-$function+)
$sub-(-((-)$error-))
$error+

hash is now  new input
move hash to v
increase once to make it between 1 and 252
$hash+
:divisor
$divisor*15+

$hash &divmod @hash
$divisor(-)

$error(-
$hash++++++++(-$divisor++++++++)$divisor---.++++
; 0|*32|rem|quot|0|0
>>(->+>+) $divisor(->>+>+) >>> . (-)
; 0|0|rem|32|*0|quot
<<(->+>+) > . (-)
; 0|0|0|*0|rem|quot
>(-<<+)
>(-<<+)
)

$divisor-
<+[-<+]--      change ~1 to ~2 at I
<++[--<++]--   @M
$c-$v+[->+]- >  back to input
[- <<+[-<+]- >++[->+]- >]      copy remainder
<+>->                             move marker
[- <<+[-<+]- >*15++[->+]- >]   copy divident
<+<@divisor

$inp-                         move marker
$function-([-<+]-@c$i++[->+]-@inp) 
$inp+
++[--<++]-                        change I to ~1 again
<+[-<+]@c                         reset m
$t+

$i new switch
  (-
   (-
    (-
     (-
      (-$t- &var_del         )
        $t (- &var_move      )
     ) $t (- &run_macro      )
    ) $t (- &var_position_set)
   ) $t (- &var_create       )
  ) $t (- &macro_create      )  
  &err_move2buf
 )
 $more(-$error+)
)
check for error
$test+                                                 ; set flag
$error(
;    ++++++++++++++++++++++++++++++++++++++++++++++++.
    >->-->>>>@error                                    ; shortest code to induce error
)
$test[-
read another byte and exit if EOF
$buf+$I+[- $buf- @function ]
>[[-@buf $I- $function+ $buf, #[+[- $function- ]]]
>[-@function $inp]]]
)                                      ; loop until read EOF == 0/ -1/ no change

&print_if_stack_error
