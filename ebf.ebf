;[
;
;ebf.ebf a bf compiler v1. In addition to existing BF (<>+-,.[])
;we have current extra commands:
;
; ;  == comment rest of line (no change)
; !a == deallocate variable a. It is assumed that is is cleared and last variable allocated
; :a == allocate variable a. It will take any available place
; $a == move to a
; @a == indicate that we are at a (usefull for asymetric loops
; like :a:b:c $b+ $a[ $b- ] either in a or b compiler thinks b $c[ @b - $c ])
;
; By Pål Wester
; ]

:c variable crumble
:n variable value
:z zero
:g global variable index
:i input
:t temporary
:w working
:a adding aide
:p position
:e error number
++++++++[->++++++++<]>                              ; 64
[->>>>>>>[>>>>>>>>]+[<<<<<<<<]>]                    ; 8*64 = 512
>>>>>>>[->>>>>>>>]                                  ; goto 520
@i ; indicates that we are on i

$i ,[                                               ; outer loop. EOF=0

; copy $i to $w
[- $t+ $w+ $i ]                                     ; pour $i to $w and $t
$t [- $i+ $t  ]                                     ; pour $t to $i
+                                                   ; i=I|t=1|w=I|p=x|n=0|v=0
; switch
$a +++[- $w ----------- $a]                         ; reduce $w with 3*11=33(!)
 $w [---                                            ; no, reduce $w with 3($)
  [ $a++[- $w----------- $a ] $w                        ; no, reduce $w with 22(:)
   [ -                                              ; no, reduce by 1 (;)
    [ -                                             ; no, reuce by 1 (<)
     [ --                                           ; no, reuce by 2 (>)
      [ --                                          ; no, reduce by 2 (@)
       [ $i . $t- $w [-] ]                          ; reset $t and $w
       $t [-                                        ; in @
            $e++++$p[-]-$i.$n,.[-<[<<]+[>>]<] @n    ; set error flag. print and move to ascii value of variable left
            $c [<<]>                                ; move to array
            [-<<<+>>>>[>>] @z                       ; copy n to p and c-1
                    $p + $e[-] $c[<<]>              ; plus reset error flag
                ]                                   ; end copy
            <<<[->>>+<<<]>>>>[->>] @z               ; restore original value
          $t] $w                                    ; in @ end
      ]$t [- $i.$p+$t ] $w                          ; in > adjusts pos
      ]$t [- $i. $a+$p[-$a-]<[-<]@w $t ] $w         ; in < adjusts pos. Make sure we don't go below 0.
    ]$t [[,----------]++++++++++.[-]] $w            ; in ; removes comment
   ]$t [-                                           ; in :
            $i.$n,.[-<[<<]+[>>]<] @n                ; move to ascii value of variable left

            error checking code for double assignment
            $c[<<]>[                                ; move to n(i) check if non zero
              >[>>]@z $e+ $c[<<]>                   ; when non zero go to e and set 1 (: error)
            [-]]>[>>]@z                             ; back to z

            $g+[- $t+ $c[<<]>+>[>>] @z >]           ; increment g and copy g to t and n
            $c [<<]>>[->>] @z                       ; clear trail
            $t [- $g+ $t]                           ; restore new g
     $t]$w                                          ; in : end
  ]$t [                                             ; move to a ($)
            $i.[-]$n,.[-<[<<]+[>>]<] @n             ; move to ascii value of variable left
            $c [<<]>                                ; if zero it is not defined.
            [-<<<+>>>>[>>] @z $i + $a + $c [<<]>]   ; copy n to i and a and c-1
            <<<[->>>+<<<]>>>>[->>] @z               ; restore original value
            <++++++[->++++++++++<]                  ; 60 in z (<)

            error checking is i 0 set e to 2 t is still 1
            $i[-$t-$a-
            ; we have new position in i and old in p
            $w+$p[ $a [-$w-]<[@w-
                $p[-$z.$p] + $t] $w+$p-]            ; a is smaller than p, eg. <
            $z++$w-$a[-$z.$a]$z[-]
            $i[-$p+$i]                              ; set current position

            $t]>[@t$e++$t->]@w                      ; set error flag if t is not set
  $t] $w
 ]$t [- remove var
        $e+++$i.$g-                                 ; prnit and reduce g
        $n,.[-<[<<]+[>>]<] @n                       ; read and move to ascii value of variable left
        $c[<<]>[
            >[>>]@z$e[-]$c[<<]>                     ; remove error flag (because value is positive)
            [-]                                     ; reset value
        ]>[->>]@z                                   ; restore

 $t]                                                ; end !
check for error
$t+                                                 ; set flag
$e[
    >+++++++++[->++++++++<]>---                      ; prints ERROR using previous block
    .+++++++++++++..---.+++.                         ; and both previous and cuurent block is zero after

    we probably want support for individual         ; 1=:, 2=$, 3=!, 4=@
    error messages in the future

    $i[-]$t-$e[-]                                    ; remove flag
]
$t[-                                                ; if flag set (no error)
$i[-]
read another byte and exit if EOF
$i[-]$t+$i,+[-$t-]                                  ; in $i or $t (compiler thinks $t)
$w[- t >]@w $t] $i ]                                ; loop until read EOF == 0/ -1/ no change




